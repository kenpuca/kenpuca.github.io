<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Courses on db@uoit</title>
    <link>https://kenpuca.github.io/courses/</link>
    <description>Recent content in Courses on db@uoit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://kenpuca.github.io/courses/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/algorithms/insert-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/insert-sort/</guid>
      <description>

&lt;h1 id=&#34;basic-programming&#34;&gt;Basic programming&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:6&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We use &lt;em&gt;Python&lt;/em&gt; for this course.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Basic Python will do for the most part of this course.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you are not used to Python (anymore), you are only &lt;em&gt;one&lt;/em&gt; day away
of catching up.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codecademy.com/learn/python&#34;&gt;https://www.codecademy.com/learn/python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;programming-this-course&#34;&gt;Programming &amp;amp; This Course&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:6&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t need much programming for this course because we absolutely will be
focused on the &lt;em&gt;algorithms&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But &amp;hellip;&lt;/p&gt;

&lt;p&gt;The reality is that &lt;em&gt;programming&lt;/em&gt; is absolutely essential.&lt;/p&gt;

&lt;h1 id=&#34;basic-programming-for-this-course&#34;&gt;Basic programming for this course&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = [1, 2, 3]

print &amp;quot;The middle number is %d&amp;quot; % x[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need arrays as a fundamental data structure.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student:
    name = &amp;quot;Unknown&amp;quot;
    age = 18

    def __init__(self, name):
        self.name = name

jack = Student(&amp;quot;Jack&amp;quot;)

print &amp;quot;%s: %s&amp;quot; % (jack.name, jack.age)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need objects.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;i = 0
while i &amp;lt; 10:
  print i
  i += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(10):
  print i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Various loops are needed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; ==================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def reverse_string(s):
    reversed_s = &amp;quot;&amp;quot;
    for c in s:
      reversed_s += c
    return reversed_s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need functions, mostly to better organize the implementation of an algorithm.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; ============&lt;/p&gt;

&lt;p&gt;We may need to rely on external Python libraries for data generation and visualization of algorithmic actions.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;random-graph.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import networkx as nx
import matplotlib.pyplot as plot

G = nx.erdos_renyi_graph(100, 0.015)
nx.draw(G)
plot.save(&amp;quot;random-graph.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;the-sorting-problem&#34;&gt;The sorting problem&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 9:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Input:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An array of elements: $x$
where the elements are to be compared by a &lt;em&gt;comparator&lt;/em&gt; function:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$f(x_1, x_2) \in \left[
\begin{array}{cc}
-1 &amp;amp; x_1 &amp;lt; x_2 \\
0 &amp;amp; x_1 = x_2 \\
1 &amp;amp; x_1 &amp;gt; x_2
\end{array}\right.$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Output:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A permutation $y$ of the array of $x$, such that&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\forall i,j\in[0, \mathrm{length}(y)],\quad i\leq j \implies y[i] \leq y[j]$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This is called &lt;em&gt;comparison based sorting&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The comparison function can be arbitrary, and it defines the ordering.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-sorting-problem-1&#34;&gt;The sorting problem&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Permutation $\pi : [0, n] \to [0, n]$ such that &lt;code&gt;$i\not= j\implies \pi(i)\not=\pi(j)$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a sorting problem $(x, f)$, there can be multiple non-unique permutations that sorts $x$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = [3, 2, 2, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;insertion-sort&#34;&gt;Insertion sort&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a highly &lt;em&gt;inefficient&lt;/em&gt; sorting algorithm.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It&amp;rsquo;s simple enough that:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It&amp;rsquo;s intuitive.&lt;/li&gt;
&lt;li&gt;It can be fully analyzed relatively easily.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;insertion-sort-the-intuition&#34;&gt;Insertion sort: the intuition&lt;/h1&gt;

&lt;p&gt;Suppose you have an array such that the &lt;em&gt;initial&lt;/em&gt; subarray is already sorted.  But the last element may be out of place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x&#34;&gt;+---+---+---+----+---+
| 2 | 4 | 5 | 10 | x |
+---+---+---+----+---+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Q&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is a procedure to rearrange such array?  Imagine that &lt;code&gt;x=7&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;insertion-sort-1&#34;&gt;Insertion sort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=cards.png width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Chapter 2, Figure 2.1 of textbook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python nu&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;try-it-out&#34;&gt;Try it out&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;import random
A = [random.randint(0, 100) for i in range(10)]
print A
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;insertion_sort(A)
print A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;



&lt;iframe 
    
    data-src=&#39;http://db.science.uoit.ca:8080/?arg=kenpu/python&#39;
    
    style=&#39;max-width:100%;width:100%;height:500px&#39;&gt;&lt;/iframe&gt;



&lt;h1 id=&#34;analysis-of-correctness&#34;&gt;Analysis of correctness&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Intuition is not to be trusted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can formally prove that an algorithm is correct.
But first, we need some machinery.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;loop-invariance&#34;&gt;Loop invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Consider a loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;total = 0
count = 0

for v in array:
  total += v
  count += 1

avg = total / count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Precondition of a loop:
a statement that is &lt;strong&gt;always&lt;/strong&gt; *true at the start of
the loop.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Postcondition of a loop:
a statement that is &lt;strong&gt;always&lt;/strong&gt; true at by the end of
the loop.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Loop invariance&lt;/strong&gt;:
a statement that is &lt;strong&gt;always&lt;/strong&gt; true
&lt;span style=color:#44f;font-size:120%&gt;right at the end&lt;/span&gt;
of each iteration of
the loop.&lt;/p&gt;

&lt;p&gt;At the &lt;em&gt;end&lt;/em&gt; of the $i$-th iteration:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;$_i$ $\not=$ &lt;code&gt;0&lt;/code&gt;
&lt;i class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;total&lt;/code&gt;&lt;code&gt;$_{i+1} \geq$&lt;/code&gt; &lt;code&gt;total&lt;/code&gt;&lt;code&gt;$_i$&lt;/code&gt;
&lt;i class=&#34;fa fa-thumbs-down&#34;&gt;&lt;/i&gt;:
This is not a loop-invariance because it may not be true.
Consider if $v &amp;lt; 0$ for some iteration.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are two loops, with &lt;code&gt;while&lt;/code&gt;-loop nested in the &lt;code&gt;for&lt;/code&gt;-loop.&lt;/p&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-1&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Inner-loop invariance&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If we assume that $A[0 .. j-1]$ is sorted, then
the following loop invariance holds for the &lt;code&gt;for&lt;/code&gt; loop:&lt;/p&gt;

&lt;p&gt;At the end of the iteration, we have $A[i\dots j]$ is sorted.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;Can we say anything about &lt;code&gt;A[j+1]&lt;/code&gt; to &lt;code&gt;A[len(A)-1]&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-2&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Outer-loop invariance&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The subarray &lt;code&gt;A[0 .. j]&lt;/code&gt; is sorted after the $j$-th iteration of the &lt;code&gt;for&lt;/code&gt;-loop.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;: We prove by induction on $j$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Base case&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$j=0$, trivially true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Induction&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If &lt;code&gt;A[0 .. j-1]&lt;/code&gt; is sorted, by the inner-loop invariance, moving key to
&lt;code&gt;A[i+1]&lt;/code&gt; makes &lt;code&gt;A[0 .. j]&lt;/code&gt; sorted.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-3&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Theorem&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;insertion_sort&lt;/code&gt; algorithm always correctly sorts the input array.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;By the outer-loop invariance, by the end of the last iteration,
with $j=$&lt;code&gt;len(A)-1&lt;/code&gt;, the entire array &lt;code&gt;A[0 .. len(A)-1]&lt;/code&gt; is sorted.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;h1 id=&#34;performance-analysis&#34;&gt;Performance analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;h3 id=&#34;every-statement-takes-the-same-amount-of-time&#34;&gt;Every statement takes the same amount of time.&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;This is not exactly correct, but it is accurate enough to gauge the
performance of algorithms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;corollary&#34;&gt;&lt;em&gt;Corollary&lt;/em&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;We measure the number of lines executed by the program before an array is
completely sorted by &lt;code&gt;insertion_sort&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;$T_\mathrm{LOC}(\mathrm{length}(A)) \Rightarrow T(n)$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Best case analysis&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Worst case analysis&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Average case analysis&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Worst case analysis&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let $n = \mathrm{length}(A)$&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The outer-loop &lt;em&gt;always&lt;/em&gt; iterates $n$ times.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The inner loop iterates &lt;em&gt;in the worst case&lt;/em&gt; $j$ times.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;$$ T(n) \leq \sum_{j=0}^n j = \frac{n(n-1)}{2}$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;insert_sort&lt;/code&gt; is a pretty inefficient algorithm.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;time (1M LOC/s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;45 $\mu s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;4950&lt;/td&gt;
&lt;td&gt;5 $ms$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;499500&lt;/td&gt;
&lt;td&gt;0.5 $s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td&gt;499999500000&lt;/td&gt;
&lt;td&gt;5.9 days&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A more efficient algorithm (to be discussed later):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;time (1M LOC/s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;23 $\mu s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;460&lt;/td&gt;
&lt;td&gt;0.46 $ms$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;6907&lt;/td&gt;
&lt;td&gt;6.9 $s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td&gt;13815510&lt;/td&gt;
&lt;td&gt;13.8 $s$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;INSERTION sort&lt;/li&gt;
&lt;li&gt;Analysis of correctness by loop-invariance&lt;/li&gt;
&lt;li&gt;Performance analysis by counting lines executed&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Text: 2.1, 2.2,&lt;/p&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is INSERTION sort a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/algorithms/merge-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/merge-sort/</guid>
      <description>

&lt;h1 id=&#34;mergesort&#34;&gt;Mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Divide and conquer, when and when not&amp;hellip;&lt;/li&gt;
&lt;li&gt;Bottom-up&lt;/li&gt;
&lt;li&gt;Top-down&lt;/li&gt;
&lt;li&gt;Correctness&lt;/li&gt;
&lt;li&gt;Complexity analysis&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;divide-and-conquer&#34;&gt;Divide and conquer&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a way to instruct &amp;ldquo;simple&amp;rdquo; solver to solve a complex problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img data-src=&#34;Minion.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img data-src=&#34;office-messy-desk.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;divide-and-conquer-and-combine&#34;&gt;Divide and conquer (and combine)&lt;/h1&gt;

&lt;p&gt;Divide:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a problem $P$, the division of a problem is a procedure
that produces a collection of &lt;em&gt;smaller&lt;/em&gt; problems &lt;code&gt;$\mathbf{Q} = \{Q_1, Q_2, \dots\}$&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Conquer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each sub-problem &lt;code&gt;$Q_i\in\mathbf{Q}$&lt;/code&gt; (hopefully) is easier to solve.
Let &lt;code&gt;$S_i = \mathrm{solve}(Q_i)$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hopefully, the solutions of subproblems, ${S_i}$, are not useless toward the
solution of $P$.&lt;/p&gt;

&lt;p&gt;We need a procedure to combine:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\mathrm{solve}(P) = \mathrm{combine}(S_1, S_2, S_3, \dots)$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;example-cleaning-a-mess&#34;&gt;Example: cleaning a mess&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;Minion.jpg&#34; style=&#34;float:left;width:80px;margin:0 20px 0px 0&#34;&gt;&lt;/img&gt;
Consider how you can instruct a minion to clean a messy office.  The minion
is overwhelmed by the mess of the entire office.  Divide and conquer is a great
way to solve the cleaning problem.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here are some assumptions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The minion can clean up a very small section of an office - like a drawer, or
a book shelf.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If every section of an office is organized, we deem the whole office
organized.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;example-cleaning-a-mess-1&#34;&gt;Example: cleaning a mess&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide(Office) = &lt;code&gt;{Bookshelf, Desk, Floor, Cabinet, Drawer, $\dots$}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conquer: the minion can clean up each section&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combine: Nothing needs to be done&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Divide &amp;amp; Conquer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A list of numbers can be divided into smaller lists.
If a list is so small, we can sort it trivially.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How small does a list need to be for us to know how to sort it?&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer-1&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If we have two lists that are already sorted, can we figure out how to combine
them in a sorted way?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;+---+---+---+---+
| 1 | 5 | 6 | 8 |          \
+---+---+---+---+          |
                           |
                           +------&amp;gt;  combined sorted list
                           |
+---+---+---+---+----+     |
| 3 | 4 | 5 | 8 | 10 |     /
+---+---+---+---+----+
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer-2&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 10:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def merge(list1, list2):
    i, j = 0, 0
    list3 = []

    while i &amp;lt; len(list1) and j &amp;lt; len(list2):
        if list1[i] &amp;lt;= list2[j]:
            list3.append(list1[i])
            i += 1
        else:
            list3.append(list2[j])
            j += 1

    if i &amp;lt; len(list1): list3.extend(list1[i:])

    if j &amp;lt; len(list2): list3.extend(list2[j:])

    return list3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We want to be able to merge to sorted list into a larger list.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/kenpu/df50d5b42ed4abb0c4749284111005d6.js?file=merge.py&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;bottom-up-mergesort&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;bottom-up-mergesort-1&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;p&gt;We start with a list of arbitrary lenght $n$.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Observe that &lt;em&gt;all&lt;/em&gt; sublist of length 1 is already sorted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;merge()&lt;/code&gt; to improve the &lt;em&gt;sortedness&lt;/em&gt; of the list to length 2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;merge()&lt;/code&gt; to improve the &lt;em&gt;sortedness&lt;/em&gt; of the list to length 4, 8, 16, &amp;hellip;
until the whole list is sorted.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;bottom-up-mergesort-2&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bottom-up-mergesort-3&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;script src=&#34;//gist.github.com/kenpu/df50d5b42ed4abb0c4749284111005d6.js?file=mergesort.py&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;bottom-up-mergesort-4&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A hierarchy of subproblems&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Small subproblems: sublist of length 1&lt;/p&gt;

&lt;p&gt;Larger subproblems: sublist of length 2, 4, &amp;hellip;&lt;/p&gt;

&lt;p&gt;The largest subproblem: the whole list&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Why is it called &lt;em&gt;bottom-up&lt;/em&gt;?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The procedure, &lt;code&gt;mergesort()&lt;/code&gt;, recognizes the smallest subproblems &lt;em&gt;first&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;divide&lt;/strong&gt; stage starts at the bottom of the hierarchy.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;conquer&lt;/strong&gt; stage &lt;em&gt;always&lt;/em&gt; starts with the bottom of the hierarchy.&lt;/p&gt;

&lt;h1 id=&#34;analysis-correctness&#34;&gt;Analysis: correctness&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Loop-invariance:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At the end of each loop,&lt;/p&gt;

&lt;p&gt;for all $L[i\Delta \dots (i+1)\Delta]$ is sorted for all $i$,
where $\Delta$ is the sortedness at the end of the iteration.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Overall correctness&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The loop terminates when $\Delta$ exceeds the length of the list, so the
entire list is sorted by the loop invariance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Guaranteed termination&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration strictly increases the sortedness $\Delta$ (by doubling it).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;analysis-performance&#34;&gt;Analysis: performance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;How many iterations if there are $n$ elements in the list?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration grows the &lt;em&gt;sortedness&lt;/em&gt; by a factor of 2 up to $n$.
So, we need $\log_2(n)$ iterations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How many instructions does each iteration take?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration has four steps.  Each step requires no more than a linear scan
of the list.
We can guarantee that number of instructions do not exceed: $k\cdot n$ for some
constant $k$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Putting it together:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mergesort()&lt;/code&gt; requires no more than $k\cdot n\log(n)$ number of instructions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;top-down-mergesort&#34;&gt;Top-down mergesort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;top-down-mergesort-1&#34;&gt;Top-down mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Revisit the hierarchy of subproblems of sorting a list&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can specify the &lt;em&gt;Divide-and-conquer&lt;/em&gt; top-down:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Divide sorting of $L$ to the first sublist $L[0 \dots \frac{n}{2}]$
and the second sublist $L[\frac{n}{2} \dots n]$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the sub-lists are not easy enough, then break down again.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Recursion&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;top-down-mergesort-analysis&#34;&gt;Top-down mergesort: Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;correctness&#34;&gt;Correctness:&lt;/h2&gt;

&lt;p&gt;Induction on depth of recursion.&lt;/p&gt;

&lt;p&gt;Base case: depth = 0&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If there is no recursion, than the list $L$ is such that $|L|\leq 1$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Inductive case: depth = $k$, and assume that all mergesort at level $&amp;lt; k$ are
correct.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Let $L_1$ and $L_2$ be the two sublists.  The invocations &lt;code&gt;mergesort($L_i$)&lt;/code&gt;
use $&amp;lt; k$ recursions, and thus, are &lt;em&gt;correct&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Since $L_1$ and $L_2$ are properly sorted, and that &lt;code&gt;merge()&lt;/code&gt; is correct,
we conclude that &lt;code&gt;mergesort(L)&lt;/code&gt; is correct.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;top-down-mergesort-analysis-1&#34;&gt;Top-down mergesort: Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;performance&#34;&gt;Performance&lt;/h2&gt;

&lt;p&gt;Let $n = |L|$.  How much time does it take to complete top-down
&lt;code&gt;mergesort($L$)&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Let $T(n)$ = time of &lt;code&gt;mergesort($L$)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray*}
T(n) &amp;amp;\simeq&amp;amp; T(n/2) + T(n/2) + n \\
  &amp;amp;=&amp;amp; 2 T(n/2) + n
\end{eqnarray*}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will develop an array of techniques to solve &lt;em&gt;recurrence equations&lt;/em&gt; to
analyze recursive algorithms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Spoiler Alert:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$$ T(n) = n\log(n) + n $$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide and conquer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bottom-up mergesort&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Top-down mergesort&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is &lt;code&gt;MERGESORT&lt;/code&gt; a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/algorithms/optimal-sorting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/optimal-sorting/</guid>
      <description>

&lt;h1 id=&#34;optimal-comparison-based-sorting-br-v-s-br-numerical-sorting&#34;&gt;Optimal Comparison Based Sorting &lt;br&gt; v.s. &lt;br&gt;  Numerical Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Assumption&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elements in the array are &lt;em&gt;black boxes&lt;/em&gt;, and only comparison can be made between two elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;The decision-tree model&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a sorting algorithm $A$, we record &lt;em&gt;all&lt;/em&gt; possible comparison operations executed in $A$.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; A comparison operation: $(i,j)$ where $i, j$ are the &lt;em&gt;original&lt;/em&gt; index of the elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The leaf records the final ordering of the original index.&lt;/p&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting-1&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How many comparison operations did $A$ take as illustrated in the diagram?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the worst case number of comparision operations?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting-2&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What type of tree is the deicion tree?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Binary tree&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How many leaf nodes are there for $n$ elements?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All possible permutations of $[1, 2, 3, \dots n] = n!$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the height of the tree if there are $n!$ leaf nodes?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$\log_2(n!) \approx c\dot n\log(n)$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;optimal-comparison-based-sorting&#34;&gt;Optimal Comparison Based Sorting&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Any comparision based sorting algorithm will necessarily take at least $c n\log(n)$ number of comparison operations in the &lt;em&gt;worst&lt;/em&gt; case.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Optimal sorting&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a comparison based sorting algorithm always makes at most $c n\log(n)$ number of comparisons, then it&amp;rsquo;s called &lt;em&gt;optimal&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;optimal-comparison-based-sorting-1&#34;&gt;Optimal Comparison Based Sorting&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Algorithm&lt;/th&gt;
&lt;th&gt;Optimal?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Insertion sort&lt;/td&gt;
&lt;td&gt;No, $n^2$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Mergesort&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Quicksort&lt;/td&gt;
&lt;td&gt;No, $n^2$ in the worst case&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sorting-integers&#34;&gt;Sorting Integers&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If an array contains (bounded) integers, we can beat optimal comparison based sorting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Why?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Elements are not blackboxes.  We can look at individual digits of an bounded integer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;counting-sort&#34;&gt;Counting sort&lt;/h1&gt;

&lt;p&gt;Assumptions:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The elements are integers.&lt;/li&gt;
&lt;li&gt;The elements are all in the range of $[0, k-1]$ for some $k \geq 0$.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Amazing fact:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;With $n$ elements, we can do it with only $2\cdot(n+k)$ number of instructions,
compare to $n\log(n)$ in the case of optimal comparison sorting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;counting-sort-1&#34;&gt;Counting sort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def empty_array(size, init=None):
    return [init for i in range(size)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; allocate an empty array with an optional initial value.&lt;/p&gt;

&lt;h1 id=&#34;counting-sort-2&#34;&gt;Counting sort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def COUNTING_SORT(A):
    n = len(A)
    k = max(A) + 1
    B = empty_array(size=n)
    C = empty_array(size=k, init=0)

    for a in A:
        C[a] = C[a] + 1

    for i in range(1,k):
        C[i] = C[i] + C[i-1]

    for a in reversed(A):
        B[C[a]-1] = a
        C[a] = C[a] - 1

    return B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;We compute the frequency of each distinct value in &lt;code&gt;A&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The frequence is then turned into cummulative frequency.  Namely:
&lt;code&gt;$C[x] = |\{y\in A: y\leq x\}|$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;With $C$, we can quickly deduce which each element should be positioned.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;counting-sort-3&#34;&gt;Counting Sort&lt;/h1&gt;

&lt;p&gt;Question:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is &lt;code&gt;COUNTING_SORT&lt;/code&gt; stable?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Answer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes.  It&amp;rsquo;s crucial to place $x$ into &lt;code&gt;B&lt;/code&gt; from &lt;code&gt;reverse(A)&lt;/code&gt; instead of &lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The best comparison sorting algorithms are in the order of $n\log(n)$.&lt;/li&gt;
&lt;li&gt;The best integer comparison algorithms can achieve the efficiency in the order of $n$.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COUNTING_SORT&lt;/code&gt; requires too much memory in practice to be applied to arrays with large integer values.  However, it will be instrumental later (as part of radix sort).&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;The measure of algorithmic efficiency will be made much more rigorous in the next section of this course.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/algorithms/quicksort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/quicksort/</guid>
      <description>

&lt;h1 id=&#34;quicksort&#34;&gt;Quicksort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;quicksort-1&#34;&gt;Quicksort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide and conquer&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a list $L$, we divide the sorting problem into two sub-problems.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Sort the elements in $L$ smaller than $x$: $L_1$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sort the elements in $L$ larger than $x$: $L_2$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combine&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$\mathrm{sorted}(L) = \mathrm{sorted}(L_1) \oplus \{x\} \oplus \mathrm{sorted}(L_2)$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;partition&#34;&gt;Partition&lt;/h1&gt;

&lt;p&gt;Given a list &lt;code&gt;$L$&lt;/code&gt; and an element $x$ in $L$, &lt;em&gt;partitioning&lt;/em&gt; $L[p \dots r]$ by the &lt;em&gt;pivot&lt;/em&gt;
element $x$ does the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rearrange the elements in $L[p\dots r]$ so that there exists a position $q$
such that &lt;em&gt;after&lt;/em&gt; rearrangment:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$L[q] = x$&lt;/li&gt;
&lt;li&gt;$\forall i\in [p, q-1],\ L[i] \leq x$&lt;/li&gt;
&lt;li&gt;$\forall i\in [q+1, r],\ L[i] \geq x$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;version-0-1-simple-but-takes-more-memory&#34;&gt;Version 0.1: simple, but takes more memory&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s implement &lt;code&gt;partition(L, p, r)&lt;/code&gt; with the minimal effort:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pick $x = L[r]$&lt;/li&gt;
&lt;li&gt;Filter the list for smaller elements: &lt;code&gt;$L_1 = \{y\in L[p\dots r-1]: y\leq x\}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Filter the list for larger elements: &lt;code&gt;$L_2 = \{y\in L[p\dots r-1]: y &amp;gt; x\}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reconstruct: &lt;code&gt;$L[p \dots r] = L_1 \oplus \{x\} \oplus L_2$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def partition(L, p, r):
    x = L[r]
    L1 = [y for y in L[p:r] if y &amp;lt;= x]
    L2 = [y for y in L[p:r] if y &amp;gt; x]
    L[p:r+1] = L1 + [x] + L2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;version-0-2-more-involved-but-takes-no-additional-memory&#34;&gt;Version 0.2: more involved, but takes no additional memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It only involves element swapping, so it requires &lt;em&gt;zero&lt;/em&gt; additional memory.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;But its correctness is much less obvious.&lt;/p&gt;

&lt;h1 id=&#34;analysis-of-partition&#34;&gt;Analysis of partition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bookkeeping is the key:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;$p$ and $r$ are the boundaries of the sublist to be partitioned.&lt;/li&gt;
&lt;li&gt;$r$ also holds the value of the pivot element.&lt;/li&gt;
&lt;li&gt;Elements in $[p\dots j]$ are processed.&lt;/li&gt;
&lt;li&gt;$i$ is a marker of the boundary between smaller and larger elements.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;analysis-of-partition-1&#34;&gt;Analysis of partition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Loop invariance:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;After each iteration, $L[p, j]$ is properly partitioned:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$L[p, i] \leq x$&lt;/li&gt;
&lt;li&gt;$L[i+1, j] &amp;gt; x$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;quicksort-2&#34;&gt;Quicksort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def quicksort(L, p, r):
    if p &amp;lt; r:
        k = partition(L, p, r)
        quicksort(L, p, k-1)
        quicksort(L, k+1, r)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;performance-analysis&#34;&gt;Performance Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will only give a terse outline of the analysis.  The full version is deferred to later lectures.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;performance-analysis-1&#34;&gt;Performance Analysis&lt;/h1&gt;

&lt;p&gt;Let there be $n$ elements in the array.&lt;/p&gt;

&lt;p&gt;Key obsevation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;partition(L, p, r)&lt;/code&gt; takes $(r - p)$ iterations.  Each iteration has a fixed number of instructions.  So, $T_\mathrm{partition} = c_1 (r-p) \leq c\cdot n$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;At each &lt;em&gt;invocation&lt;/em&gt; of &lt;code&gt;quicksort(L, p, k-1)&lt;/code&gt; and &lt;code&gt;quicksort(L, k+1, r)&lt;/code&gt;, we need to determine the number of elements: $k-1-p$, and $r-k-1$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;performance-analysis-worst-case&#34;&gt;Performance Analysis: Worst-case&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The worst case for $T_\mathrm{partition} = n$&lt;/li&gt;
&lt;li&gt;The worst case for $k-1-p = n-1$&lt;/li&gt;
&lt;li&gt;The worst case for $r-k-1 = n-1$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;We have enough to set-up an equation to estimate the number of instructions of &lt;code&gt;quicksort(L, a, b)&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;Let $|L[a\dots b]| = n$.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\begin{eqnarray}
T_\mathrm{quicksort}(n) &amp;amp;=&amp;amp; n + 2\cdot T_\mathrm{quicksort}(n-1)
\end{eqnarray}$$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This leads to a (poor) performance characteristics of: $\approx n^2$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will show how to solve such equations (known as recurrence equations) in the next section of this course.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;performance-analysis-average-case&#34;&gt;Performance Analysis: average case&lt;/h1&gt;

&lt;p&gt;Quicksort as the name suggests is actually quite quick (most of the time&amp;hellip;)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Revisiting &lt;code&gt;k = partition(L, p, q)&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The pivot value should be somewhere in the middle of the subarray.
Namely: $k\approx p+q/2$, and so $k-1-p \approx n/2$, and $q-k-1\approx n/2$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Revisiting the recurrence equation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\begin{eqnarray}
T_\mathrm{quicksort}(n) &amp;amp;=&amp;amp; n + 2\cdot T_\mathrm{quicksort}(n/2)
\end{eqnarray}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;This leads to a satisfying performance characteristics of: $\approx n\log(n)$&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Partition: a simple version&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Partition: a zero-memory version&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Quicksort: a recursive sorting algorithm&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is &lt;code&gt;QUICKSORT&lt;/code&gt; a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/programming-languages/functional-computation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/functional-computation/</guid>
      <description>

&lt;h1 id=&#34;lambda-calculus-symbolic-computation&#34;&gt;$\lambda$-Calculus: symbolic computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lambda-calculus&#34;&gt;$\lambda$-Calculus&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Proposed by Alonzo Church in ~1930.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;intented to formalize mathematics.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Syntactic expressions that represent &lt;em&gt;functions&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;designed to represent the entire foundation of mathematics.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Rules of rewriting the syntactic expression&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;rewrite rules represent mathematical reasoning.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;expressions&#34;&gt;Expressions&lt;/h1&gt;

&lt;p&gt;Values&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Literals: 1, 2, 3, &amp;ldquo;Hello world&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Variables: $x, y, z, \dots$&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Functions&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$+ : (x,y)\mapsto x+y$&lt;/li&gt;
&lt;li&gt;$\mathrm{inc} : x\mapsto x+1$&lt;/li&gt;
&lt;li&gt;$\dots$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Always returns &lt;em&gt;one&lt;/em&gt; value.&lt;/li&gt;
&lt;li&gt;Takes a fixed number of inputs: arity of the function
&lt;span style=color:red&gt;*&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;value-as-function&#34;&gt;Value as function&lt;/h1&gt;

&lt;p&gt;A value is a zero-arity function.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;function-as-value&#34;&gt;Function as value&lt;/h1&gt;

&lt;p&gt;We want to extend the idea of &lt;em&gt;things&lt;/em&gt; to include functions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;This is a central idea in functional programming&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;value-equiv-function-everything&#34;&gt;Value $\equiv$ Function = Everything&lt;/h2&gt;

&lt;h1 id=&#34;syntax-for-expressions-value-function&#34;&gt;Syntax for expressions (value / function)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$x, y, z, \dots$ are expressions&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Abstraction:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;If $x$ is a variable, and $e$ is an expression, then
$\lambda x. e$ is an expression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Application:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;If $e_1$ is a function with arity 1,
&lt;code&gt;$e_2$&lt;/code&gt; is an expression, then
$e_1 e_2$ is an expression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We assume that all functions are with arity 1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is not a restriction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;the-weird-syntax-of-lambda-calculus&#34;&gt;The &lt;em&gt;weird&lt;/em&gt; syntax of $\lambda$ calculus&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$\lambda x.e$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is a function taking &lt;em&gt;one&lt;/em&gt; input, represented by the variable $x$.
It returns &lt;em&gt;one&lt;/em&gt; value, which is evaluated as the expression $e$.
The expression $e$ usually makes uses of $x$, but not necessarily.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$e_1 e_2$&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is passing $e_2$ as an argument to the expression $e_1$.  Recall that
everything is a function.  So $e_1$ is a function with &lt;em&gt;one&lt;/em&gt; argument.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$e_1 e_2 e_3 = ((e_1 e_2) e_3)$&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This shows that $e_1$ takes one argument ($e_2$), and returns an
expression which is yet again a function which takes $e_3$ as an input.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;defining-things&#34;&gt;Defining things&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Identity function&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$\lambda x.x$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Functions with multiple arity&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose we have a function $f(x,y,z) = e$ where the expression
involves all three input variables $x, y, z$.&lt;/p&gt;

&lt;p&gt;We can use the following expression to build $f$:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$\lambda x.(\lambda y.(\lambda z. e))$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;This is a big deal.&lt;/strong&gt; &lt;br&gt;
&lt;strong&gt;Functions as values in action here.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=height:220px&gt;&lt;/div&gt;

&lt;p&gt;We can write it conveniently as $\lambda xyz.e$&lt;/p&gt;

&lt;h1 id=&#34;computing-with-lambda-calculus&#34;&gt;Computing with $\lambda$-Calculus&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We rely on string-rewriting to evaluate
LC expressions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;substitution-of-variables-in-function-applications&#34;&gt;Substitution of variables in function applications&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Notation&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$e[x/e&amp;rsquo;]$ is the expression obtained by substituting all occurances of $x$ in
the expression $e$ with the expression $e&amp;rsquo;$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Substition&lt;/strong&gt; as a way to evaluate function application:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$(\lambda x. e) e&amp;rsquo; \implies e[x/e&amp;rsquo;]$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray}
&amp;amp;&amp;amp; (\lambda x.x x) (\lambda y. y) \\
&amp;amp;\implies&amp;amp; (x x)[x/(\lambda y.y)] \\
&amp;amp;\implies&amp;amp; (\lambda y.y)(\lambda y.y) \\
&amp;amp;\implies&amp;amp; y[y/(\lambda y.y)] \\
&amp;amp;\implies&amp;amp; (\lambda y.y)
\end{eqnarray}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We can easily get into trouble.&lt;/p&gt;

&lt;p&gt;Substitution cannot be used freely.&lt;/p&gt;

&lt;h1 id=&#34;free-bound-variables&#34;&gt;Free &amp;amp; Bound Variables&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Variables in a function abstraction expression can be &lt;em&gt;free&lt;/em&gt; or &lt;em&gt;bound&lt;/em&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a variable represents the input parameter in a function expression, then
it&amp;rsquo;s considered &lt;em&gt;bound&lt;/em&gt;.  Otherwise, it&amp;rsquo;s &lt;em&gt;free&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;$\mathbf{FV}(e)$ are the free variables of $e$&lt;/li&gt;
&lt;li&gt;$\mathbf{BV}(e)$ are the bound variables&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;variable-capturing&#34;&gt;Variable Capturing&lt;/h1&gt;

&lt;p&gt;Consider an expression:&lt;/p&gt;

&lt;p&gt;$$\lambda x. (\lambda x.x)$$&lt;/p&gt;

&lt;p&gt;There are multiple occurrences of $x$, so let&amp;rsquo;s label them so we can refer to
the individual occurrences.&lt;/p&gt;

&lt;p&gt;$$\lambda x_1. (\lambda x_2.x_3)$$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Which input variable does $x_3$ refer to?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; This is called capturing.&lt;/p&gt;

&lt;h1 id=&#34;elimination-of-variable-capturing&#34;&gt;Elimination of Variable Capturing&lt;/h1&gt;

&lt;p&gt;There is a rewrite rule that allows us to rename the parameter variables without
changing the meaning of the expression.&lt;/p&gt;

&lt;p&gt;$$ \lambda x. x \equiv \lambda y.y \equiv \lambda \mathsf{hello}.\mathsf{hello} $$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Renaming&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose that $x$ is a free variable of $e$, and $y$ does not appear in $e$ at
all.&lt;/p&gt;

&lt;p&gt;Then $\lambda x.e \implies \lambda y.e[x/y]$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;elimination-of-variable-capturing-1&#34;&gt;Elimination of Variable Capturing&lt;/h1&gt;

&lt;p&gt;Back to:&lt;/p&gt;

&lt;p&gt;$$\lambda x. (\lambda x.x)$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;First we consider the sub expression $\lambda x.x$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Using renaming, we can rewrite it to $\lambda y.y$.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Then we get:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$$\lambda x. (\lambda x.x) \implies \lambda x.\lambda y. y$$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt;
Generally, we only apply &lt;strong&gt;substitution&lt;/strong&gt; to evaluate function applications
if there is &lt;em&gt;no&lt;/em&gt; variable capturing; and this can be achieved by &lt;strong&gt;renaming&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;how-to-perform-computation-using-lc&#34;&gt;How to perform computation using LC?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Natural numbers&lt;/li&gt;
&lt;li&gt;Arithmetics&lt;/li&gt;
&lt;li&gt;Loop and conditional branching&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;All can be done using LC&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Express the algorithm in terms of natural numbers, arithmetics,
 loops and conditional branches.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Encode the algorithm in LC.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Apply syntax rewriting until no more rewriting is possible.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;a-glance-of-lc-in-action&#34;&gt;A glance of LC in action&lt;/h1&gt;

&lt;p&gt;A bit of notation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$\lambda x.\lambda y. \lambda z. e$ is written as as $\lambda xyz. e$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Now we can encode numbers:&lt;/p&gt;

&lt;p&gt;$0 \equiv \lambda sx. x$ (takes two inputs, but only keep the second one.)&lt;/p&gt;

&lt;p&gt;$1 \equiv \lambda sx. sx$&lt;/p&gt;

&lt;p&gt;$2 \equiv \lambda sx. ssx$&lt;/p&gt;

&lt;p&gt;$\vdots$&lt;/p&gt;

&lt;h1 id=&#34;arithmetics&#34;&gt;Arithmetics&lt;/h1&gt;

&lt;p&gt;Consider the simplest arithmetics: increment by 1.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def succ(n):
    return n + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$S \equiv \lambda n. \lambda yx.y(nyx)$$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let&amp;rsquo;s try this out.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray}
S 0 &amp;amp;=&amp;amp; (\lambda n. \lambda yx.ynyx)0 \\
    &amp;amp;=&amp;amp; (\lambda yx.ynyx)[n/0] \\
    &amp;amp;=&amp;amp; \lambda yx.y(0yx) \\
    &amp;amp;=&amp;amp; \lambda yx.y((\lambda sz.z)yx) \\
    &amp;amp;=&amp;amp; \lambda yx.y(x) \\
    &amp;amp;=&amp;amp; 1
\end{eqnarray}&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;arithmetics-1&#34;&gt;Arithmetics&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add(n1, n2):
    return n1 + n2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Observe:&lt;/p&gt;

&lt;p&gt;$2 S 3 = 5$ (work it out, it&amp;rsquo;s quite incredible.)&lt;/p&gt;

&lt;p&gt;So, we have:&lt;/p&gt;

&lt;p&gt;$$+ \equiv \lambda mn. mSn$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Can you guess the LC expression for multiplication?&lt;/p&gt;

&lt;h1 id=&#34;recursion&#34;&gt;Recursion&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LC does not require assigning aliases to functions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Technically, there is just &lt;strong&gt;ONE&lt;/strong&gt; expression for the entire algorthm.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why it&amp;rsquo;s hard to do recursion without aliases?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def factorial(n):
    if n &amp;lt;= 1:
        return n
    else:
        return n * factorial(n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Is it even possible?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes.  It&amp;rsquo;s called the &lt;strong&gt;Y&lt;/strong&gt;-combinator.&lt;/p&gt;

&lt;p&gt;$$ \mathbf{Y} \equiv (\lambda y.(\lambda x.y(xx))(\lambda x.y(xx)))$$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;y-combinator&#34;&gt;Y-combinator&lt;/h1&gt;

&lt;p&gt;$$ \mathbf{Y} f = f (\mathbf{Y} f) $$&lt;/p&gt;

&lt;p&gt;So,&lt;/p&gt;

&lt;p&gt;$$ \mathbf{Y} f x \implies f (\mathbf{Y} f) x \implies f f \dots f x $$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; $\mathbf{Y} f$ is a &lt;em&gt;fixed point&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;using-y-combinator-to-implement-factorial&#34;&gt;Using Y-combinator to implement factorial&lt;/h1&gt;

&lt;p&gt;Consider a function $F$ as:&lt;/p&gt;

&lt;p&gt;$$\lambda fx. (\mathrm{ifzero}\ x)\ 1\ (*\ x\ (f\ (\mathrm{dec}\ x)))$$&lt;/p&gt;

&lt;p&gt;If we apply the Y-combinator to $F$, we get:&lt;/p&gt;

&lt;p&gt;$$ (\mathbf{Y} F) n = F (\mathbf{Y} F) n $$&lt;/p&gt;

&lt;p&gt;You can check the following:&lt;/p&gt;

&lt;p&gt;$$ (\mathbf{Y} F) n = (\mathrm{ifzero}\ n)\ 1\ (*\ n\ ((\mathbf{Y} F)\ (\mathrm{dec}\ n))) $$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is really quite amazing.  We have achieved Turing-completeness via recursion.  The amazing part is that we don&amp;rsquo;t need variables to refer to any values.  So $F$ is just for convenience and readability.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LC is purely symbolic.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It carries out computation by very simple string rewrites:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Function application&lt;/li&gt;
&lt;li&gt;Variable renaming&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It solves problem by:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Encode the problem as a single (huge) string of LC expression.&lt;/li&gt;
&lt;li&gt;Using the rules to rewrite the string to a &lt;em&gt;normal&lt;/em&gt; form.&lt;/li&gt;
&lt;li&gt;The resulting LC expression is the answer.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No variables are needed.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/programming-languages/old/intro-to-languages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/old/intro-to-languages/</guid>
      <description>

&lt;h1 id=&#34;computation-in-practice&#34;&gt;Computation in practice&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Languages based on stateful computation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Languages based on functional computation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hybrid languages&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;stateful-computation&#34;&gt;Stateful computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Languages&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Javascript&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Task&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Quicksort&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;X = [6, 3, 4, 8, 1, 4]

def quicksort(X, i, j):
  if i &amp;lt; j:
    p = partition(X, i, j)
    quicksort(X, i, p-1)
    quicksort(X, p+1, j)

def partition(X, i, j):
  pivot = X[j]
  m = i
  for n in range(i, j):
    if X[n] &amp;lt;= pivot:
      X[m], X[n] = X[n], X[m]
      m += 1
  X[m], X[j] = X[j], X[m]
  return m

def QuickSort(X):
  return quicksort(X, 0, len(X)-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;breakdown-of-python&#34;&gt;Breakdown of python&lt;/h1&gt;

&lt;div pdf=&#34;qsort-py.pdf&#34; scale=0.8&gt;&lt;/div&gt;

&lt;h1 id=&#34;python-v-s-javascript&#34;&gt;Python v.s. Javascript&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;script
src=&#34;https://gist.github.com/kenpu/e2e3fcc9feea16fb14a84c7ec98cdd75.js?file=qsort.py&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=height:600px;overflow:auto&gt;
&lt;script
src=&#34;https://gist.github.com/kenpu/e2e3fcc9feea16fb14a84c7ec98cdd75.js?file=qsort.js&#34;&gt;&lt;/script&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/programming-languages/stateful-computation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/stateful-computation/</guid>
      <description>

&lt;h1 id=&#34;computation-the-turing-machine&#34;&gt;Computation &amp;amp; the Turing Machine&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;computation&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;david-hilbert.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hilbert&amp;rsquo;s Ten&amp;rsquo;s problem, 1900&lt;/li&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-1&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;kurt-godel.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;Gdel&amp;rsquo;s incompleteness theorem&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-2&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;alan-turing.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;Turing machine&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-3&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;alonzo-church.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;$\lambda$-calculus&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-4&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;john-von-neumann.jpg&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;von Neumann computing model&lt;/li&gt;
&lt;li&gt;EDVAC&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;turing-machine&#34;&gt;Turing Machine&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A completely mechanical device (1928)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;envisioned by Alan Turing as an intuitive formalism to
describe the non-existing phenomenon of machine driven
reasoning, now known as &lt;em&gt;computation&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Realized into an actual design (1945)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;John von Neumann designed an electronic version to simulate
the mechanical definition of a TM in a document known as &lt;em&gt;First Draft of a
Report on the EDVAC&lt;/em&gt;, 1945.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Turing-complete&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TM is the most powerful computing model we know.
Up to now, we don&amp;rsquo;t know any other computing models more powerful than
a TM.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;turing-machine-1&#34;&gt;Turing Machine&lt;/h1&gt;

&lt;div pdf=&#34;turing-machine.pdf&#34; scale=0.8&gt;&lt;/div&gt;

&lt;h1 id=&#34;computational-power-of-tm&#34;&gt;Computational power of TM&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Church-Turing Thesis&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a procedure (algorithm) can be executed by &lt;em&gt;any&lt;/em&gt; computer, then it can be
executed by a Turing Machine.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Turing Complete&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a mechanism is equivalent to TM, then it&amp;rsquo;s called &lt;em&gt;Turing Complete&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;simulation-of-a-function&#34;&gt;Simulation of a function&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Computable functions&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A function $f$ is computable if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Its input can be encoded as a binary string: &lt;code&gt;$2^*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Its output can be encoded as a binary string: &lt;code&gt;$2^*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Its evaluation can always be carried out by a TM.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Any computable function can be implemented by a TM.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any TM is some computable function.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Why is a TM always a function (over binary strings)?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;universal-tm&#34;&gt;Universal TM&lt;/h1&gt;

&lt;p&gt;Consider a TM: $M$.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s a function &lt;code&gt;$M:2^*\to 2^*$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s mechanical description can be encoded as a binary string.
&lt;i style=&#34;font-size:200%;color:#faa;vertical-align:middle;margin-left:10px&#34; class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Function &lt;em&gt;eval&lt;/em&gt; takes two inputs - a TM and an input, and it computes the
output.&lt;/p&gt;

&lt;p&gt;$$\mathrm{eval} :\mathrm{TM} \times 2^* \to 2^*$$&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s input can be encoded as binary strings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It can be carried out by a procedure.
&lt;i style=&#34;font-size:200%;color:#faa;vertical-align:middle;margin-left:10px&#34; class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By Church-Turing thesis, &lt;strong&gt;eval&lt;/strong&gt; is computable, so there is a TM for it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Definition&lt;/em&gt; &lt;strong&gt;Universal TM&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The TM $\mathbf{U}$ that computes &lt;strong&gt;eval&lt;/strong&gt; is called &lt;em&gt;universal&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;universal-tm-1&#34;&gt;Universal TM&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The TM $\mathbf{U}$ initializes the tape with the binary encoding of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a TM, $M$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;an input, $x$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It outputs $\mathbf{eval}(M, x)$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Modern Computer:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$M$ is the program&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$x$ is the input to the program&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\mathbf{U}$ is the general purpose computer&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tm-programming&#34;&gt;TM-Programming&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We just need a single TM, namely $\mathbf{U}$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The universal programming language is the encoding of $M$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Turing Machine is a mechanically realizable device.&lt;/li&gt;
&lt;li&gt;TM is as powerful (but a lot slower) as any modern computers.&lt;/li&gt;
&lt;li&gt;There is a very special TM that is called the &lt;em&gt;Universal TM&lt;/em&gt;.  It can be
&lt;em&gt;programmed&lt;/em&gt;!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Algorithms</title>
      <link>https://kenpuca.github.io/courses/algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/</guid>
      <description>&lt;div class=&#34;jumbotron&#34;&gt;
	&lt;h1&gt;Design &amp; Analysis of Algorithms&lt;/h1&gt;
&lt;/div&gt;

&lt;div class=row&gt;
	&lt;div class=col-md-3&gt;
		&lt;img src=&#34;textbook.jpg&#34; width=100%&gt;&lt;/img&gt;
		&lt;figcaption&gt;
	    Introduction to Algorithms, Third Edition,
	    &lt;i&gt;Coremen, Leiserson, Rivest and Stein&lt;/i&gt;
	    &lt;/figcaption&gt;
	    &lt;p style=margin-top:10px;font-style:italic;font-size:90%&gt;
			This course is about problem solving and computation via algorithms.
			We will cover a number of known algorithms (sorting, hashing, search,
			indexing) and their applications.  We will discuss methods for analyzing
			existing algorithms and designing new algorithms.
			Finally, the students will be introduced to &lt;i&gt;complexity classes&lt;/i&gt;, in
			particular the class of &lt;i&gt;NP-completeness&lt;/i&gt;.
		&lt;/p&gt;

	&lt;/div&gt;
	&lt;div class=col-md-9&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Sorting&lt;/h1&gt;
				&lt;p&gt; Chapter 2.1, 2.3, 6, 7, 8&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;insert-sort&#34;&gt;Insertion sort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;merge-sort&#34;&gt;Mergesort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;quicksort&#34;&gt;Quicksort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;
						&lt;a href=&#34;optimal-sorting&#34;&gt;
							Comparision based sorting versus numeric sorting
						&lt;/a&gt;
					&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;sorting-numbers&#34;&gt;Sorting integers&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Analysis of Complexity&lt;/h1&gt;
				&lt;p&gt; Chapter 3, 4, 5&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;
						&lt;a href=&#34;big-o&#34;&gt;Asymptotic notations&lt;/a&gt;
						&lt;span style=&#34;float:right&#34; class=&#34;label label-warning&#34;&gt;DRAFT&lt;/span&gt;
					&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Recurrence equations&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Probabilistic analysis of randomized algorithms&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Data structures&lt;/h1&gt;
				&lt;p&gt;Chapter 10, 11, 12&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Elementary data structures&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Hash tables&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Trees&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Optimization&lt;/h1&gt;
				&lt;p&gt;Chapter 15, 16&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Dynamic programming&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Greedy algorithms&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Huffman codes&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Graphs&lt;/h1&gt;
				&lt;p&gt;Chapter 22, 23, 24, 25, 26&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Graph search&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Spanning trees&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Shortest path algorithms&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Maxflow&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Complexity &amp; Tractability&lt;/h1&gt;
				&lt;p&gt;Chapter 34&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Decision problems&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;P, NP and reduction&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;NP-complete and other complexity classes&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Computability&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

	&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt; a[href=&#34;&#34;] {color: #888;} &lt;/style&gt;
</description>
    </item>
    
    <item>
      <title>Asymptotic notation</title>
      <link>https://kenpuca.github.io/courses/algorithms/big-o/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/big-o/</guid>
      <description>

&lt;h1 id=&#34;asymptotic-notation&#34;&gt;Asymptotic notation&lt;/h1&gt;

&lt;p&gt;We will develop a way to measure the efficiency of algorithms which is &lt;em&gt;invariant&lt;/em&gt; to the non-essential issues such as the speed of computer hardware and the effiency of the programming language used.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The measurement functions is only sensitive to the &lt;em&gt;growth&lt;/em&gt; of the time it takes for an algorithm to complete with respect to the size of the input.&lt;/p&gt;

&lt;h1 id=&#34;measure&#34;&gt;Measure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The size of the input is an integer $n$&lt;/li&gt;
&lt;li&gt;We use functions over integers to measure the efficiency of an algorithm.&lt;/li&gt;
&lt;li&gt;$f(n)$ is the &lt;strong&gt;time&lt;/strong&gt; it takes to process input of size $n$ in the &lt;em&gt;worst case&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;$f$ is monotonic: if $m \leq n$, then $f(m)\leq f(n)$.&lt;/li&gt;
&lt;li&gt;$f$ is strictly positive: $f(n) &amp;gt; 0$ for all $n$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;using-functions-as-measurement-of-algorithmic-complexity&#34;&gt;Using functions as measurement of algorithmic complexity&lt;/h1&gt;

&lt;p&gt;We want to use functions to measure the inherit &lt;em&gt;complexity&lt;/em&gt; of &lt;em&gt;algorithms&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is not very straight-forward.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We don&amp;rsquo;t care about&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Runtime environment&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU speed&lt;/li&gt;
&lt;li&gt;Start-up time of the program&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implementation issues&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Speed of the language&lt;/li&gt;
&lt;li&gt;Number of statements used&lt;/li&gt;
&lt;li&gt;Overhead in memory data structure&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We do care about&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inherit complexity of the algorithm&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;capturing-the-essentials&#34;&gt;Capturing the essentials&lt;/h1&gt;

&lt;p&gt;Suppose that we have an algorithm $P$.  Let&amp;rsquo;s use some function $f(n)$ to represent the time, in the &lt;em&gt;worst case&lt;/em&gt;, that $P$ takes to process an input of size $n$.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at the effects of various environmental factors on the measure $f(n)$.&lt;/p&gt;

&lt;h1 id=&#34;effects-on-the-measure&#34;&gt;Effects on the measure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$P$ is reimplemented using C (from Python), so it runs 20 times faster now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$f&amp;rsquo;(n) = \frac{1}{20} f(n)$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$P$ runs inside a &lt;em&gt;docker&lt;/em&gt; image, so it takes an additional 300 ms to start.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$f&amp;rsquo;(n) = f(n) + 300\mathrm{ms}$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But we don&amp;rsquo;t want to care about these implementation and runtime factors when investigating the complexity of algorithms.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Intuition: given $f(n)$, we define family of (infinite) functions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{better\ than}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{worse\ than}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{equivalent\ to}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;mathcal-o-notation-better-than&#34;&gt;$\mathcal{O}$-notation - better than&lt;/h1&gt;

&lt;p&gt;We want to define all function which are measure of algorithms which are better than (or same as) $g(n)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: The Big-O notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\mathcal{O}(g(n)) = \{f(n) : \exists n_0, c &amp;gt; 0,\forall n &amp;gt; n_0, \ 0 &amp;lt; f(n) &amp;lt; c\dots g(n)\}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We call $g(n)$ the asymptotic upper bound.&lt;/p&gt;

&lt;h1 id=&#34;omega-notation-worse-than&#34;&gt;$\Omega$-notation - worse than&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: The $\Omega$-notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\mathcal{O}(g(n)) = \{f(n) : \exists n_0, c &amp;gt; 0,\forall n &amp;gt; n_0, \ 0  &amp;lt; c\dots g(n) &amp;lt; f(n) \}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Bucket Sort</title>
      <link>https://kenpuca.github.io/courses/algorithms/bucket-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/bucket-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Clojure Language</title>
      <link>https://kenpuca.github.io/courses/programming-languages/clojure-language-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/clojure-language-2/</guid>
      <description>

&lt;h1 id=&#34;clojure-part-ii&#34;&gt;Clojure: Part II&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We will be covering the &lt;em&gt;rest&lt;/em&gt; of the Clojure syntax.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Native data structures beyond just lists:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;vector&lt;/li&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;li&gt;hash-map&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Iteration and branching&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Functions and higher order functions&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Clojure: the language</title>
      <link>https://kenpuca.github.io/courses/programming-languages/clojure-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/clojure-language/</guid>
      <description>

&lt;h1 id=&#34;clojure-part-i&#34;&gt;Clojure: Part I&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Life cycle of Lisp code&lt;/li&gt;
&lt;li&gt;Raw basics&lt;/li&gt;
&lt;li&gt;Syntactic sugars&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;review-of-lisp&#34;&gt;Review of Lisp&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A program is a (nested) list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Not all lists are valid programs.  Only certain type of lists can be interpreted as programs.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Valid: &lt;code&gt;(+ 1 2 (* 3 5))&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Invalid: &lt;code&gt;(1 2 +)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sometimes the validity of a list depends on the dialect of Lisp:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;(defun add (a b) (+ a b))&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Valid for &lt;em&gt;Common Lisp&lt;/em&gt;, but not &lt;em&gt;Racket&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;(define (add a b) (+ a b))&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Valid for &lt;em&gt;Racket&lt;/em&gt;, but not &lt;em&gt;Common Lisp&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;lifecycle-of-lists-in-lisp&#34;&gt;Lifecycle of lists in Lisp&lt;/h1&gt;

&lt;p&gt;The unified representation of programs using a data structure that programs can manipulate, Lisp has a uniquely self-referencial nature that makes it exceedingly powerful (and intellectually challenging).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; &lt;i style=font-size:200%;vertical-align:middle class=&#34;fa fa-bolt&#34;&gt;&lt;/i&gt; Lisp rewrites itself, and it &lt;em&gt;grows&lt;/em&gt; by itself.&lt;/p&gt;

&lt;h1 id=&#34;two-phase-compilation&#34;&gt;Two-phase compilation&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;lisp-pre-expand.jpg&#34; alt=&#34;pre-expanded&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;note 3&#34;&gt;!&lt;/a&gt; During expansion, functions, known as &lt;em&gt;macros&lt;/em&gt;, evaluate certain fragments in the program.  These fragments are the extensions to the language.&lt;/p&gt;

&lt;h1 id=&#34;two-phase-compilation-1&#34;&gt;Two-phase compilation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;lisp-post-expand.jpg&#34; alt=&#34;post-expanded&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The macro functions converts the entire nested list to a valid Lisp program.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp sm&#34;&gt;(... (macro (quote (... invalid-list ...))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gets evaluated to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp sm&#34;&gt;(... (... valid-list ...))

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;core-clojure&#34;&gt;Core Clojure&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;List-only core syntax (low-level and verbose)&lt;/li&gt;
&lt;li&gt;(Sensible) syntactic extensions&lt;/li&gt;
&lt;li&gt;Tons of macros&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;clojure&#34;&gt;Clojure&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition:&lt;/strong&gt; (Atoms)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An &lt;em&gt;atom&lt;/em&gt; is a value that can be an element of a list.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go through the different atoms of the core-clojure langauge.&lt;/p&gt;

&lt;h1 id=&#34;numbers&#34;&gt;Numbers&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Numbers&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Long numbers&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3.1415&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ratio&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1/3&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BigInt&lt;/td&gt;
&lt;td&gt;10000N&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BigDecimal&lt;/td&gt;
&lt;td&gt;3.1415M&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;strings&#34;&gt;Strings&lt;/h1&gt;

&lt;p&gt;Simple strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Hello world.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;I say \&amp;quot;Hello\&amp;quot; to the world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiline string:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;&amp;quot;Hello,
This is a big world of long
sentences.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;character&#34;&gt;Character&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;\a
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;keywords&#34;&gt;Keywords&lt;/h1&gt;

&lt;p&gt;Keywords are a staple of Clojure programs.  They are quick and efficient way to create &lt;em&gt;constants&lt;/em&gt;.
They are similar to the Java &lt;code&gt;enum&lt;/code&gt; values.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Keywords have the same rule as variable names (aka &lt;em&gt;symbols&lt;/em&gt;), except they must start with &lt;code&gt;:&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:red
:blue
:green
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:big-red-apple
:blue-sky
:important-field!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Later, we will introduce namespaces.  Like symbols, keywords can be specialized by a namespace.&lt;/p&gt;

&lt;h1 id=&#34;symbols&#34;&gt;Symbols&lt;/h1&gt;

&lt;p&gt;Symbols are variables which are labels referring to some data or function.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; It&amp;rsquo;s natural to think of Clojure symbols as variables.  But Clojure can do &lt;em&gt;more&lt;/em&gt; with its symbols than other languages can do with variables.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Clojure has some very relaxed rules in naming symbols:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;a                 ; looks like a variable.
*a*               ; can have (almost) any characters except whitespaces
int-&amp;gt;float        ; good names can be extremely satisfying
java.lang/Integer ; a symbol that has a namespace &amp;quot;java.lang&amp;quot;, and name &amp;quot;Integer&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;more-about-symbols&#34;&gt;More about symbols&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Var&lt;/em&gt; s are symbols which represent other expressions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;a =&amp;gt; 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Almost) each time a &lt;em&gt;var&lt;/em&gt; appears, it is evaluated to its expression.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Other languages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In other programming languages, one can &lt;em&gt;only&lt;/em&gt; access the expression referred by variables.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lisp&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In Lisp, we can (and need) to access (and create) the variable &lt;em&gt;itself&lt;/em&gt; using Lisp.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(var a)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;beyond-parentheses-in-clojure&#34;&gt;Beyond parentheses in Clojure&lt;/h1&gt;

&lt;p&gt;Clojure uses other brackets to improve the parentheses overload.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(let ((a 10)
      (b 20))
  (+ a b))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Common Lisp&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [a 10
      b 20]
  (+ a b))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Clojure&lt;/p&gt;

&lt;h1 id=&#34;lambda-calculus-in-clojure&#34;&gt;Lambda Calculus in Clojure&lt;/h1&gt;

&lt;p&gt;We will focus on the core Clojure - which is a Turing-complete implementation of Lambda Calculus.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Function application&lt;/li&gt;
&lt;li&gt;Function abstraction&lt;/li&gt;
&lt;li&gt;Symbol binding&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;function-application&#34;&gt;Function application&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(f &amp;lt;arg&amp;gt; &amp;lt;arg&amp;gt; ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(+ 1 2 3 4)
(/ (+ 1 2 3 4) 4.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;function-abstraction&#34;&gt;Function Abstraction&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(fn &amp;lt;alias?&amp;gt; [ &amp;lt;args&amp;gt; ] &amp;lt;body&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(fn [a b] (/ (+ a b) 2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Computing the average of two numbers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(fn factorial [n]
  (if (&amp;lt; n 2) n (* n (factorial (dec n)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Recursion function that uses an alias &lt;code&gt;factorial&lt;/code&gt; for itself.  The alias is only valid in the body of the &lt;code&gt;fn&lt;/code&gt; defintion.&lt;/p&gt;

&lt;h1 id=&#34;symbol-binding&#34;&gt;Symbol binding&lt;/h1&gt;

&lt;p&gt;Symbols are just names, and they can be used to represent anything, such as:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;expressions&lt;/li&gt;
&lt;li&gt;functions&lt;/li&gt;
&lt;li&gt;variables&lt;/li&gt;
&lt;li&gt;lists (or programs)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: &lt;em&gt;Symbols Binding&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When we associate a symbol to something else, the &lt;em&gt;association&lt;/em&gt; is called a &lt;em&gt;binding&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;symbol-binding-1&#34;&gt;Symbol binding&lt;/h1&gt;

&lt;p&gt;&lt;span style=color:red&gt;Insert diagram here&lt;/span&gt;&lt;/p&gt;

&lt;h1 id=&#34;global-symbol-binding&#34;&gt;Global symbol binding&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def &amp;lt;symbol&amp;gt; &amp;lt;expression&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Creates a global symbol binding that exists throughout the entire &lt;em&gt;namespace&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;More on &lt;em&gt;namespaces&lt;/em&gt; later&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def PI 3.1415)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def area-of-circle (fn [r] (* r r PI)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(area-of-circle 100)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;global-symbol-binding-1&#34;&gt;Global symbol binding&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Must resist the usage of global symbol binding.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Java/C/C++ tend to bind functions to global symbols.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Because functions are values, think of functions as simple as &lt;em&gt;integers&lt;/em&gt;.
So, Clojure requires minimal global symbol binding.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;em&gt;local binding&lt;/em&gt; (coming up next) as much as you can.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;local-symbol-binding&#34;&gt;Local symbol binding&lt;/h1&gt;

&lt;p&gt;We want to create new symbol bindings in expressions &lt;em&gt;on-the-fly&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;lang-nosyntax&#34; data-noescape&gt;(def two-circles
  &lt;span style=&#34;color:#944;
                border:thin solid #888;
                padding:5px;
                margin:5px;
                font-weight: bold;
                display:inline-block&#34;&gt;(+ (* 3.1415 100 100) (* 3.1415 100 100))&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Let&amp;rsquo;s create a symbol bindings which are &lt;em&gt;only&lt;/em&gt; valid in the inner-expression.&lt;/p&gt;

&lt;h2 id=&#34;span-style-color-red-bad-idea-span&#34;&gt;&lt;span style=color:red&gt;BAD IDEA&lt;/span&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def PI 3.1415)
(def radius 100)
(def area (* 3.1415 radius radius))
(def two-circles (+ area area))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
Why is it bad?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;radius&lt;/code&gt; is not really a universal constant.  It&amp;rsquo;s 100 only for this expression.&lt;/li&gt;
&lt;li&gt;same for area.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;local-symbol-binding-1&#34;&gt;Local Symbol Binding&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(...
  (let [&amp;lt;symbol&amp;gt; &amp;lt;expression&amp;gt;
        &amp;lt;symbol&amp;gt; &amp;lt;expression&amp;gt;
        ...]
    &amp;lt;inner-expression&amp;gt;) ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def PI 3.1415)
(def two-circle
  (let [r    100
        area (* PI r r)]
    (+ r r)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Can you summarize why local symbol binding is more desirable to compute the value of &lt;code&gt;two-circle&lt;/code&gt;?&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Atoms&lt;/li&gt;
&lt;li&gt;Lists as code and code as lists&lt;/li&gt;
&lt;li&gt;Functions&lt;/li&gt;
&lt;li&gt;Invocation of functions&lt;/li&gt;
&lt;li&gt;Symbol bindings (global v.s. local)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>From Lisp to Clojure</title>
      <link>https://kenpuca.github.io/courses/programming-languages/lisp-clojure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/lisp-clojure/</guid>
      <description>

&lt;h1 id=&#34;from-lisp-to-clojure&#34;&gt;From Lisp to Clojure&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Lisp&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Inspired by $\lambda$-Calculus&lt;/li&gt;
&lt;li&gt;Hyper-productive syntax&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Clojure&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Extension to Lisp&lt;/li&gt;
&lt;li&gt;Supports a slightly richer set of syntactic sugars for readability&lt;/li&gt;
&lt;li&gt;Runs on JVM&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;lisp&#34;&gt;Lisp&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Invented by John McCarthy, 1958&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s been the foundation of A.I. research ever since.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;lisp-1&#34;&gt;Lisp&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;quote1.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;lisp-2&#34;&gt;Lisp&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;quote2.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;review-of-lc&#34;&gt;Review of LC&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;abstraction&#34;&gt;Abstraction&lt;/h2&gt;

&lt;p&gt;$\lambda x. e$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Example:&lt;/p&gt;

&lt;p&gt;$\lambda x.\lambda y. x+y$&lt;/p&gt;

&lt;p&gt;$\lambda xy. x+y$ (with syntactic abbreviation)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;application&#34;&gt;Application&lt;/h2&gt;

&lt;p&gt;$(e_1 e_2)$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Example:&lt;/p&gt;

&lt;p&gt;$(((\lambda xy. x+y)\ 1)\ 2)$&lt;/p&gt;

&lt;p&gt;$((\lambda xy. x+y)\ 1\ 2)$ (abbreviation)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Observation&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;Application is always a &lt;strong&gt;list&lt;/strong&gt; of expressions.  The first expression is the function, and the rest of the list is arguments.&lt;/p&gt;

&lt;h1 id=&#34;design-of-lisp&#34;&gt;Design of Lisp&lt;/h1&gt;

&lt;p&gt;LISP = &lt;span style=color:red&gt;LIS&lt;/span&gt;t &lt;span style=color:red&gt;P&lt;/span&gt;rocessing&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Function applications are &lt;em&gt;lists&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Unless specified, lists are treated as function applications.&lt;/li&gt;
&lt;li&gt;As few additions to LC as possible while still making it humanly usable.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Results:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The entire language only needs one data structure: lists.&lt;/li&gt;
&lt;li&gt;Simplicity kicks ass.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;from-lisp-to-clojure-1&#34;&gt;From Lisp to Clojure&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;i&gt;Simplicity is hard work. But, there&amp;rsquo;s a huge payoff. The person who has a genuinely simpler system - a system made out of genuinely simple parts, is going to be able to [e]ffect the greatest change with the least work. He&amp;rsquo;s going to kick your ass. He&amp;rsquo;s gonna spend more time simplifying things up front and in the long haul he&amp;rsquo;s gonna wipe the plate with you because he&amp;rsquo;ll have that ability to change things when you&amp;rsquo;re struggling to push elephants around.&lt;/i&gt;&lt;/p&gt;

&lt;div style=float:right&gt;Rich Hickey, Inventor of Clo&lt;i&gt;j&lt;/i&gt;ure&lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;--------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=font-size:300%&gt;Why Clojure?&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dialect of Lisp&lt;/li&gt;
&lt;li&gt;Runs on JVM with native execution speed of Java&lt;/li&gt;
&lt;li&gt;Natively access Java libraries (huge deal)&lt;/li&gt;
&lt;li&gt;Ported to Javascript &amp;ndash; powers the front-end with React.js&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;homoiconic-languages&#34;&gt;Homoiconic Languages&lt;/h1&gt;

&lt;p&gt;Every language must support data structures:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Arrays: &lt;code&gt;(char*)[] names&lt;/code&gt;
Structures: &lt;code&gt;struct { char *name; }&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Javascript:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JSON: &lt;code&gt;{name: &amp;quot;Jack&amp;quot;, age: 39}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lisp:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(Nested) Lists: &lt;code&gt;(1 (2 3) (4 (5 6 7)))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a language $L$, let $\mathbf{D}(L)$ be all possible data structures that can be represented by the language.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;homoiconic-languages-1&#34;&gt;Homoiconic Languages&lt;/h1&gt;

&lt;p&gt;Every language must support a (sometimes VAST) collectio of programming constructs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;for(int i=0; i &amp;lt; 10; i++) { ... }&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Rust:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;fn foo(v1: Vec&amp;lt;i32&amp;gt;, v2: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {...}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lisp:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(Nested) lists: &lt;code&gt;(when (nice weather) (go outside))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Program&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a language $L$, let $\mathbf{P}(L)$ be all possible (valid) programs that can be constructed in the langauge.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;homoiconic-languages-2&#34;&gt;Homoiconic Languages&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A language $L$ is homoiconic if:&lt;/p&gt;

&lt;p&gt;$$ \mathbf{P}(L) \subseteq \mathbf{D}(L) $$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Make sure you understand this property.&lt;/p&gt;

&lt;p&gt;It means that a homoiconic language can always digest its own program as data, and treat its data as programs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;backbone-of-lisp-s-expressions&#34;&gt;Backbone of Lisp: S-expressions&lt;/h1&gt;

&lt;p&gt;S-expressions can be two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nested lists, or&lt;/li&gt;
&lt;li&gt;A completely valid Lisp program.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;Atoms:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Atoms&lt;/em&gt; are values such as strings, characters, numbers or symbols.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lists:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A bracket enclosed, whitespace separated list of elements.  Each element can
be an atom or a list.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;S-expression:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A &lt;em&gt;s-exp&lt;/em&gt; is a list.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;s-expression&#34;&gt;S-expression&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cfg&#34;&gt;s-expr    : &#39;(&#39; expr-list &#39;)&#39;

expr-list : elem expr-list
          | &amp;lt;Empty&amp;gt;

elem      : s-expr
          | &amp;lt;Atom&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This summarizes the Lisp syntax.&lt;/p&gt;

&lt;h1 id=&#34;s-expressions-as-syntax&#34;&gt;S-expressions as syntax&lt;/h1&gt;

&lt;p&gt;S-expressions are so simple that designing programming constructs with with becomes &lt;em&gt;obvious&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Declaring a function&lt;/li&gt;
&lt;li&gt;Declaring a variable (this is done with a more general mechanism known as &lt;em&gt;name binding&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;Invoking (evaluating) a function with given parameters&lt;/li&gt;
&lt;li&gt;When a list is just a list&lt;/li&gt;
&lt;li&gt;Flow control&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;s-expressions-as-function-declaration&#34;&gt;S-expressions as function declaration&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Recall in LC:&lt;/p&gt;

&lt;p&gt;$$\lambda xyz. \left&amp;lt;\mathrm{expression}\right&amp;gt;$$&lt;/p&gt;

&lt;p&gt;Here, we need a function name.&lt;/p&gt;

&lt;p&gt;$$\left&amp;lt;\mathrm{name}\right&amp;gt; := \lambda xyz. \left&amp;lt;\mathrm{expression}\right&amp;gt;$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Turning it into a S-expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun &amp;lt;name&amp;gt; ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Treat the parameters as a list&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun &amp;lt;name&amp;gt; (x y z) &amp;lt;body&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach of encoding function declaration to s-expressions is used by &lt;em&gt;Common Lisp&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;dialects&#34;&gt;Dialects&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(define (&amp;lt;name&amp;gt; x y z) &amp;lt;body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the function name is grouped together with the parameters.  This approach is used by &lt;em&gt;Racket&lt;/em&gt; (formerly known as &lt;em&gt;Scheme&lt;/em&gt;).&lt;/p&gt;

&lt;h1 id=&#34;name-binding&#34;&gt;Name binding&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;(define PI 3.1415)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;local-name-bindings&#34;&gt;Local name bindings&lt;/h1&gt;

&lt;p&gt;Create a &lt;em&gt;scope&lt;/em&gt; with a new nested list:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(let ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create additional &amp;ldquo;local&amp;rdquo; variables in the scope:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(let ((x &amp;lt;expression&amp;gt;)
      (y &amp;lt;expression&amp;gt;)) &amp;lt;body&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is the syntax of Common Lisp.&lt;/p&gt;

&lt;h1 id=&#34;function-invocation&#34;&gt;Function invocation&lt;/h1&gt;

&lt;p&gt;Because this is considered to be the &lt;em&gt;most&lt;/em&gt; frequently used programming construct, it is represented simply by a list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(&amp;lt;name&amp;gt; &amp;lt;expression&amp;gt; &amp;lt;expression&amp;gt; ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;when-a-list-is-just-a-list&#34;&gt;When a list is just a list&lt;/h1&gt;

&lt;p&gt;What if we really mean to represent a list of elements?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(quote (&amp;lt;element&amp;gt; &amp;lt;element&amp;gt; ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This suppresses the inner list as function evaluation.&lt;/p&gt;

&lt;h1 id=&#34;branching&#34;&gt;Branching&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(if &amp;lt;test&amp;gt; &amp;lt;when-true&amp;gt; &amp;lt;when-false&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;if&lt;/code&gt; start of a list indicates that it is a branching form.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It can only have four elements.&lt;/li&gt;
&lt;li&gt;The second element, &lt;code&gt;&amp;lt;test&amp;gt;&lt;/code&gt;, is the condition.&lt;/li&gt;
&lt;li&gt;The third element, &lt;code&gt;&amp;lt;when-true&amp;gt;&lt;/code&gt;, is evaluated if the condition is true.&lt;/li&gt;
&lt;li&gt;The fourth element, &lt;code&gt;&amp;lt;when-false&amp;gt;&lt;/code&gt;, is evaluated if the condition is false.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;rolling-up-the-sleeves&#34;&gt;Rolling up the sleeves&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s flex the &lt;strong&gt;power&lt;/strong&gt; of simplicity.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We have only been dealing with lists.&lt;/li&gt;
&lt;li&gt;Some lists start with distinct names, like &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Some nesting of lists needs to be respected, like grouping the parameters as a nested list.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Challenge&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute the factorial of 100.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;rolling-up-the-sleeves-1&#34;&gt;Rolling up the sleeves&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Challenge&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute the factorial of 100.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp sm clipboard&#34;&gt;(define (factorial n)
  (if (&amp;lt; n 2) 
    n 
    (* n (factorial (- n 1)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;



&lt;iframe 
    
    data-src=&#39;http://db.science.uoit.ca:8080/?arg=kenpu/racket&#39;
    
    style=&#39;max-width:100%;width:100%;height:400px&#39;&gt;&lt;/iframe&gt;



&lt;h1 id=&#34;moving-on-from-lisp-to-clojure&#34;&gt;Moving on from Lisp to Clojure&lt;/h1&gt;

&lt;p&gt;Lisp is &lt;em&gt;simple&lt;/em&gt; (and thus powerful) in syntax.  At the same time, it&amp;rsquo;s also simple in terms of the data structure it can support.  No native support for vectors (dynamic list with random access), hash-maps (associative collections), sets (list without order or multiplicity), &amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Clojure is &lt;em&gt;Lisp&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Clojure faithfully minimizes syntax by sticking with s-expressions for programming constructs, so it remains &lt;em&gt;homoiconic&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Clojure extends &lt;em&gt;Lisp&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It adds more syntax (YES&amp;hellip;) to support a richer &lt;em&gt;data&lt;/em&gt; constructors for vectors, hash-map etc&amp;hellip;  It also support even more succinct definition of functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;clojure-at-a-glance&#34;&gt;Clojure at a glance&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(defn f [n] (if (&amp;lt; n 2) n (* n (f (dec n)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The &lt;code&gt;dec&lt;/code&gt; function decreases an integer by 1.  You might want to know about &lt;code&gt;bigint&lt;/code&gt; function which converts an integer to a BigInteger, when computing the value &lt;code&gt;(f 100)&lt;/code&gt;.&lt;/p&gt;



&lt;iframe 
    
    data-src=&#39;http://db.science.uoit.ca:8080/?arg=kenpu/clojure&#39;
    
    style=&#39;max-width:100%;width:100%;height:300px&#39;&gt;&lt;/iframe&gt;



&lt;h1 id=&#34;clojure-at-a-glance-1&#34;&gt;Clojure at a glance&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(import java.util.Vector)
(let [v (java.util.Vector. (quote (1 2 &amp;quot;blah&amp;quot;)))]
  (println &amp;quot;Last element =&amp;quot; (.lastElement v)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Wow, we are converting a Lisp list &lt;code&gt;(1 2 &amp;quot;blah&amp;quot;)&lt;/code&gt; to a Java vector object, and using the method &lt;code&gt;java.util.Vector.lastElement&lt;/code&gt; to access the last element.  &amp;hellip; &lt;strong&gt;And we are still just using nested lists.&lt;/strong&gt;&lt;/p&gt;



&lt;iframe 
    
    data-src=&#39;http://db.science.uoit.ca:8080/?arg=kenpu/clojure&#39;
    
    style=&#39;max-width:100%;width:100%;height:300px&#39;&gt;&lt;/iframe&gt;



&lt;h1 id=&#34;looking-ahead&#34;&gt;Looking ahead&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;We will &lt;em&gt;not&lt;/em&gt; use Common Lisp, nor Scheme, nor Racket for this course.&lt;/li&gt;
&lt;li&gt;We will explore Clojure into great detail instead.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Once we have lists, we immediately have an entire programming language.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All variations of PL based on (nested) lists are referred to as Lisp.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clojure is a particularly attactive Lisp as it can immediately tap into the vast ecosystem of Java libraries.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Programming Languages</title>
      <link>https://kenpuca.github.io/courses/programming-languages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/</guid>
      <description>&lt;div class=&#34;jumbotron&#34;&gt;
	&lt;h1&gt;Programming Languages&lt;/h1&gt;
&lt;/div&gt;

&lt;div class=row&gt;
	&lt;div class=col-md-3&gt;
	    &lt;p style=margin-top:10px;font-style:italic;font-size:90%&gt;
			The topic of this course is the theory and practice of *programming languages*.  We will be focused on the design principles and programming patterns of several programming languages from different programming paradigms.  We will pay particular attention to the program techniques in functional programming, and why they are gaining greater importance in modern programming.
		&lt;/p&gt;
		&lt;img src=&#34;text-1.png&#34; width=100%&gt;&lt;/img&gt;
		&lt;img src=&#34;text-2.png&#34; width=100%&gt;&lt;/img&gt;
		&lt;img src=&#34;text-3.png&#34; width=100%&gt;&lt;/img&gt;
	&lt;/div&gt;
	&lt;div class=col-md-9&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Foundations of computation&lt;/h1&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;stateful-computation&#34;&gt;Stateful computation&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;functional-computation&#34;&gt; Symbolic computation&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;
						&lt;a href=&#34;tour-of-languages&#34;&gt;Programming languages&lt;/a&gt;
					&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Functional programming in &lt;b&gt;Clojure&lt;/b&gt;&lt;/h1&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;lisp-clojure&#34;&gt;Lisp &amp; Clojure&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;clojure-language&#34;&gt;Readers - form - data - function&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li class=list-group-item&gt;
                        &lt;a href=&#34;clojure-language-2&#34;&gt;General purpose programming
                            with Clojure&lt;/a&gt;
                        &lt;span style=float:right class=&#34;label label-warning&#34;&gt;Draft&lt;/span&gt;
                    &lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Sequences, Lazy evaluation and other functional constructs&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Namespaces and polymorphism&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Lisp in other languages&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Object oriented programming in &lt;b&gt;Scala&lt;/b&gt;&lt;/h1&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Syntax and semantics of Scala&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Classes, objects and traits&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Types&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Functions&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Collections&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Pattern matching&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Namespaces&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Concurrency and reactive programming&lt;/h1&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Concurrency in Clojure&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Concurrency in Scala&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Concurrency in other languages&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Reactive programming&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Advanced topics&lt;/h1&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Macros&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Logical programming&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

	&lt;/div&gt;
&lt;/div&gt;


&lt;style&gt; a[href=&#34;&#34;] {color: #888;} &lt;/style&gt;
</description>
    </item>
    
    <item>
      <title>Sorting numbers</title>
      <link>https://kenpuca.github.io/courses/algorithms/sorting-numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/sorting-numbers/</guid>
      <description>

&lt;h1 id=&#34;radix-sort&#34;&gt;Radix Sort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A scalable and efficient sorting algorithm.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Assumes all the elements are &lt;strong&gt;integers&lt;/strong&gt; bounded by the number of digits.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is much more practical than the assumption of &lt;code&gt;COUNTING_SORT&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;radix-sort-1&#34;&gt;Radix Sort&lt;/h1&gt;

&lt;p&gt;Intuition:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Write each integer as &lt;code&gt;$x = x_n x_{n-1} \dots x_3 x_2 x_1$&lt;/code&gt; base $k$.  The least significant digit is $x_1$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Consider $x = $ one thousand four hundred and thirty seven.&lt;/p&gt;

&lt;p&gt;We can write&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$x$ in base-10: $x = 1437$.&lt;/li&gt;
&lt;li&gt;$x$ in base-16: $x = 59d$.&lt;/li&gt;
&lt;li&gt;$x$ in base-2: $x = 10110011101$&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;radix-sort-2&#34;&gt;Radix Sort&lt;/h1&gt;

&lt;p&gt;Intuition:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Write each element in $A$ with $n$ digits of base $k$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Repeatly sort the array, $A$, $n$ times, sorting by only one digit.  Start sorting by the least significant digit, and finish by the most significant digit.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The digit sorting algorithm used &lt;strong&gt;must&lt;/strong&gt; be &lt;strong&gt;stable&lt;/strong&gt;.  Use &lt;code&gt;COUNTING_SORT&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;radix-sort-3&#34;&gt;Radix Sort&lt;/h1&gt;

&lt;p&gt;Some help from Python:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;# convert a number to its binary representation
def radix2(num):
    return &amp;quot;{0:b}&amp;quot;.format(num)

# Get the i-th digit of binary string x
def digit(num, i):
    x = radix2(num)
    if i &amp;gt;= len(x):
        return 0
    else:
        d = x[-(i+1)]
        return 0 if d == &#39;0&#39; else 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;radix-sort-4&#34;&gt;Radix Sort&lt;/h1&gt;

&lt;p&gt;Modify &lt;code&gt;COUNTING_SORT(A, i)&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;# Sort A using binary digit i
def COUNTING_SORT(A, i):
    n = len(A)
    k = 2
    B = empty_array(size=n)
    C = empty_array(size=k, init=0)

    for a in A:
        d = digit(a, i)
        C[d] = C[d] + 1

    for j in range(1,k):
        C[j] = C[j] + C[j-1]

    for a in reversed(A):
        d = digit(a, i)
        B[C[d]-1] = a
        C[d] = C[d] - 1

    return B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Note that $k = 2$, we always assume binary encoding.  This is just for convenience.&lt;/li&gt;
&lt;li&gt;Instead of computing the (cumulative) frequency of elements of &lt;code&gt;A&lt;/code&gt;, we use the $i$-th digit,
&lt;code&gt;digit(a, i)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;radix-sort-5&#34;&gt;Radix Sort&lt;/h1&gt;

&lt;p&gt;Finally the radix sort algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def RADIX_SORT(A):
    n = max(len(radix2(x)) for x in A)
    for i in range(n):
        A = COUNTING_SORT(A, i)
    return A
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;on-radix-sort&#34;&gt;On Radix Sort&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;We introduced a very important sorting algorithm that is capable of sorting collections of very large integers (e.g. 64-bit values).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Stable&lt;/li&gt;
&lt;li&gt;Very efficient: beats the best comparison based sorting algorithms&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sorting-the-reals&#34;&gt;Sorting the Reals&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sorting decimal numbers between [0, 1]&lt;/li&gt;
&lt;li&gt;Bucket sort&lt;/li&gt;
&lt;li&gt;Efficient in the average case&lt;/li&gt;
&lt;li&gt;Inefficient in the worst case&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sorting-the-reals-1&#34;&gt;Sorting the Reals&lt;/h1&gt;

&lt;p&gt;Real numbers:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Any number, with arbitrary precision&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Assumption:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We are concerned with sorting arrays of real numbers whose values are between $[0, 1]$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;As long as the values are bounded by any interview $[a, b]$, we can apply the algorithm developed here by means of normalization:&lt;/p&gt;

&lt;p&gt;$$ x&amp;rsquo; = \frac{x - a}{b - a}$$&lt;/p&gt;

&lt;h1 id=&#34;intuition&#34;&gt;Intuition&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Partition the interval [0, 1] into $n$ equally divided intervals:&lt;/p&gt;

&lt;p&gt;$$B = \big[0, \frac{1}{n}\big), \big[\frac{1}{n}, \frac{2}{n}\big), \dots, \big[\frac{n-1}{n}, 1\big]$$&lt;/p&gt;

&lt;p&gt;with $B_i = [\frac{i}{n}, \frac{i+1}{n})$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given an array $A$, distribute $x\in A$ into the respective buckets $B_i$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sort each $B_i$ individually, and then concatenate all sorted buckets.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;This is &lt;em&gt;surprisingly&lt;/em&gt; effective.&lt;/p&gt;

&lt;h1 id=&#34;bucket-sort&#34;&gt;Bucket Sort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def bucketsort(A, n):
    buckets = [[] for i in range(n)]
    # distribute the buckets
    for a in A:
        i = int(math.floor(a * n))
        INSERT_SORT(buckets[i])
    # sort each bucket
    for bucket in buckets:
        bucket.sort()

    # place the elements from the sorted buckets
    # back to the array
    i = 0
    for bucket in buckets:
        for a in bucket:
            A[i] = a
            i += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bucket-sort-1&#34;&gt;Bucket Sort&lt;/h1&gt;

&lt;p&gt;We will defer the analysis of bucket sort to later as it will greatly benefit from some probability and asympotic notations.&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Numbers are &lt;em&gt;easier&lt;/em&gt; to sort than blackboxed elements.&lt;/li&gt;
&lt;li&gt;For bounded integers, we can use radix sort even if the bound is very very large (e.g. 256-bit integers).&lt;/li&gt;
&lt;li&gt;For bounded reals, we can use bucket sort.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>