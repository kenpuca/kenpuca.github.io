<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>db@uoit</title>
    <link>https://kenpuca.github.io/</link>
    <description>Recent content on db@uoit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Jul 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kenpuca.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Building a desk</title>
      <link>https://kenpuca.github.io/writings/build-desk/</link>
      <pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/writings/build-desk/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-0.jpg&#34; alt=&#34;The block in its initial condition&#34; /&gt;
Someone gave me a really gorgeous piece of wood.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s exactly what I was hoping to get my hands on.  Given that I have
absolutely minimal experience working with woods.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;I got a steel brush for a few bucks.
The wood is completely dry, and it was surprisingly easy to remove the dusty
layer off the surface with some hard brushing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-1-brush.jpg&#34; alt=&#34;Steel brush&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-2-corner.jpg&#34; alt=&#34;Rough corner&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The block of wood is full of unique characteristics.  After all, it&amp;rsquo;s these
things that make it so much fun.
This particular piece has a rough corner.  I didn&amp;rsquo;t want to do much about it
except sawing it lightly, and sanding down possible splitters.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;I got some wood oil and stains from Canadian Tires.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-3-stain.jpg&#34; alt=&#34;Starting to stain the wood&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-4-stained.jpg&#34; alt=&#34;The next day...&#34; /&gt;
After a few coats of wood stain and gloss finish, it looks absolutely great.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;The legs are from IKEA.  Putting the legs are easy enough.  The wood is quite
soft, and it&amp;rsquo;s really quite easy to drill the guiding holes for the screws.&lt;/p&gt;

&lt;p&gt;The only really hard part is that the wood is not perfectly flat, so I had to
put some inserts and adjusted them repeated to make sure that the legs are
perfectly leveled.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-5-legs.jpg&#34; alt=&#34;Putting on the legs&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-6-finished.jpg&#34; alt=&#34;All done.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Finally&lt;/em&gt;, it&amp;rsquo;s all done.  Actually, it was so much easier than I thought It
would have been.  I am so thankful that the wood was already nicely polished
to start with.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;I am happy to report that this blog is written on the desk.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-7-workstation.jpg&#34; alt=&#34;Workstation...&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&#34;sign&#34;&gt;Ken Pu &lt;br&gt; July 15, Oshawa&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/algorithms/insert-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/insert-sort/</guid>
      <description>

&lt;h1 id=&#34;basic-programming&#34;&gt;Basic programming&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:6&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We use &lt;em&gt;Python&lt;/em&gt; for this course.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Basic Python will do for the most part of this course.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you are not used to Python (anymore), you are only &lt;em&gt;one&lt;/em&gt; day away
of catching up.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codecademy.com/learn/python&#34;&gt;https://www.codecademy.com/learn/python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;programming-this-course&#34;&gt;Programming &amp;amp; This Course&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:6&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t need much programming for this course because we absolutely will be
focused on the &lt;em&gt;algorithms&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But &amp;hellip;&lt;/p&gt;

&lt;p&gt;The reality is that &lt;em&gt;programming&lt;/em&gt; is absolutely essential.&lt;/p&gt;

&lt;h1 id=&#34;basic-programming-for-this-course&#34;&gt;Basic programming for this course&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = [1, 2, 3]

print &amp;quot;The middle number is %d&amp;quot; % x[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need arrays as a fundamental data structure.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student:
    name = &amp;quot;Unknown&amp;quot;
    age = 18

    def __init__(self, name):
        self.name = name

jack = Student(&amp;quot;Jack&amp;quot;)

print &amp;quot;%s: %s&amp;quot; % (jack.name, jack.age)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need objects.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;i = 0
while i &amp;lt; 10:
  print i
  i += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(10):
  print i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Various loops are needed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; ==================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def reverse_string(s):
    reversed_s = &amp;quot;&amp;quot;
    for c in s:
      reversed_s += c
    return reversed_s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need functions, mostly to better organize the implementation of an algorithm.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; ============&lt;/p&gt;

&lt;p&gt;We may need to rely on external Python libraries for data generation and visualization of algorithmic actions.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;random-graph.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import networkx as nx
import matplotlib.pyplot as plot

G = nx.erdos_renyi_graph(100, 0.015)
nx.draw(G)
plot.save(&amp;quot;random-graph.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;the-sorting-problem&#34;&gt;The sorting problem&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 9:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Input:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An array of elements: $x$
where the elements are to be compared by a &lt;em&gt;comparator&lt;/em&gt; function:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$f(x_1, x_2) \in \left[
\begin{array}{cc}
-1 &amp;amp; x_1 &amp;lt; x_2 \\
0 &amp;amp; x_1 = x_2 \\
1 &amp;amp; x_1 &amp;gt; x_2
\end{array}\right.$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Output:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A permutation $y$ of the array of $x$, such that&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\forall i,j\in[0, \mathrm{length}(y)],\quad i\leq j \implies y[i] \leq y[j]$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This is called &lt;em&gt;comparison based sorting&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The comparison function can be arbitrary, and it defines the ordering.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-sorting-problem-1&#34;&gt;The sorting problem&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Permutation $\pi : [0, n] \to [0, n]$ such that &lt;code&gt;$i\not= j\implies \pi(i)\not=\pi(j)$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a sorting problem $(x, f)$, there can be multiple non-unique permutations that sorts $x$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = [3, 2, 2, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;insertion-sort&#34;&gt;Insertion sort&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a highly &lt;em&gt;inefficient&lt;/em&gt; sorting algorithm.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It&amp;rsquo;s simple enough that:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It&amp;rsquo;s intuitive.&lt;/li&gt;
&lt;li&gt;It can be fully analyzed relatively easily.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;insertion-sort-the-intuition&#34;&gt;Insertion sort: the intuition&lt;/h1&gt;

&lt;p&gt;Suppose you have an array such that the &lt;em&gt;initial&lt;/em&gt; subarray is already sorted.  But the last element may be out of place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x&#34;&gt;+---+---+---+----+---+
| 2 | 4 | 5 | 10 | x |
+---+---+---+----+---+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Q&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is a procedure to rearrange such array?  Imagine that &lt;code&gt;x=7&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;insertion-sort-1&#34;&gt;Insertion sort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=cards.png width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Chapter 2, Figure 2.1 of textbook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python nu&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;try-it-out&#34;&gt;Try it out&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;import random
A = [random.randint(0, 100) for i in range(10)]
print A
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;insertion_sort(A)
print A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;



&lt;iframe 
    
    data-src=&#39;http://db.science.uoit.ca:8080/?arg=kenpu/python&#39;
    
    style=&#39;max-width:100%;width:100%;height:500px&#39;&gt;&lt;/iframe&gt;



&lt;h1 id=&#34;analysis-of-correctness&#34;&gt;Analysis of correctness&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Intuition is not to be trusted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can formally prove that an algorithm is correct.
But first, we need some machinery.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;loop-invariance&#34;&gt;Loop invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Consider a loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;total = 0
count = 0

for v in array:
  total += v
  count += 1

avg = total / count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Precondition of a loop:
a statement that is &lt;strong&gt;always&lt;/strong&gt; *true at the start of
the loop.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Postcondition of a loop:
a statement that is &lt;strong&gt;always&lt;/strong&gt; true at by the end of
the loop.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Loop invariance&lt;/strong&gt;:
a statement that is &lt;strong&gt;always&lt;/strong&gt; true
&lt;span style=color:#44f;font-size:120%&gt;right at the end&lt;/span&gt;
of each iteration of
the loop.&lt;/p&gt;

&lt;p&gt;At the &lt;em&gt;end&lt;/em&gt; of the $i$-th iteration:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;$_i$ $\not=$ &lt;code&gt;0&lt;/code&gt;
&lt;i class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;total&lt;/code&gt;&lt;code&gt;$_{i+1} \geq$&lt;/code&gt; &lt;code&gt;total&lt;/code&gt;&lt;code&gt;$_i$&lt;/code&gt;
&lt;i class=&#34;fa fa-thumbs-down&#34;&gt;&lt;/i&gt;:
This is not a loop-invariance because it may not be true.
Consider if $v &amp;lt; 0$ for some iteration.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are two loops, with &lt;code&gt;while&lt;/code&gt;-loop nested in the &lt;code&gt;for&lt;/code&gt;-loop.&lt;/p&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-1&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Inner-loop invariance&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If we assume that $A[0 .. j-1]$ is sorted, then
the following loop invariance holds for the &lt;code&gt;for&lt;/code&gt; loop:&lt;/p&gt;

&lt;p&gt;At the end of the iteration, we have $A[i\dots j]$ is sorted.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;Can we say anything about &lt;code&gt;A[j+1]&lt;/code&gt; to &lt;code&gt;A[len(A)-1]&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-2&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Outer-loop invariance&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The subarray &lt;code&gt;A[0 .. j]&lt;/code&gt; is sorted after the $j$-th iteration of the &lt;code&gt;for&lt;/code&gt;-loop.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;: We prove by induction on $j$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Base case&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$j=0$, trivially true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Induction&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If &lt;code&gt;A[0 .. j-1]&lt;/code&gt; is sorted, by the inner-loop invariance, moving key to
&lt;code&gt;A[i+1]&lt;/code&gt; makes &lt;code&gt;A[0 .. j]&lt;/code&gt; sorted.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-3&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Theorem&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;insertion_sort&lt;/code&gt; algorithm always correctly sorts the input array.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;By the outer-loop invariance, by the end of the last iteration,
with $j=$&lt;code&gt;len(A)-1&lt;/code&gt;, the entire array &lt;code&gt;A[0 .. len(A)-1]&lt;/code&gt; is sorted.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;h1 id=&#34;performance-analysis&#34;&gt;Performance analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;h3 id=&#34;every-statement-takes-the-same-amount-of-time&#34;&gt;Every statement takes the same amount of time.&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;This is not exactly correct, but it is accurate enough to gauge the
performance of algorithms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;corollary&#34;&gt;&lt;em&gt;Corollary&lt;/em&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;We measure the number of lines executed by the program before an array is
completely sorted by &lt;code&gt;insertion_sort&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;$T_\mathrm{LOC}(\mathrm{length}(A)) \Rightarrow T(n)$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Best case analysis&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Worst case analysis&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Average case analysis&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Worst case analysis&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let $n = \mathrm{length}(A)$&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The outer-loop &lt;em&gt;always&lt;/em&gt; iterates $n$ times.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The inner loop iterates &lt;em&gt;in the worst case&lt;/em&gt; $j$ times.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;$$ T(n) \leq \sum_{j=0}^n j = \frac{n(n-1)}{2}$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;insert_sort&lt;/code&gt; is a pretty inefficient algorithm.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;time (1M LOC/s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;45 $\mu s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;4950&lt;/td&gt;
&lt;td&gt;5 $ms$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;499500&lt;/td&gt;
&lt;td&gt;0.5 $s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td&gt;499999500000&lt;/td&gt;
&lt;td&gt;5.9 days&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A more efficient algorithm (to be discussed later):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;time (1M LOC/s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;23 $\mu s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;460&lt;/td&gt;
&lt;td&gt;0.46 $ms$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;6907&lt;/td&gt;
&lt;td&gt;6.9 $s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td&gt;13815510&lt;/td&gt;
&lt;td&gt;13.8 $s$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;INSERTION sort&lt;/li&gt;
&lt;li&gt;Analysis of correctness by loop-invariance&lt;/li&gt;
&lt;li&gt;Performance analysis by counting lines executed&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Text: 2.1, 2.2,&lt;/p&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is INSERTION sort a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/algorithms/merge-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/merge-sort/</guid>
      <description>

&lt;h1 id=&#34;mergesort&#34;&gt;Mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Divide and conquer, when and when not&amp;hellip;&lt;/li&gt;
&lt;li&gt;Bottom-up&lt;/li&gt;
&lt;li&gt;Top-down&lt;/li&gt;
&lt;li&gt;Correctness&lt;/li&gt;
&lt;li&gt;Complexity analysis&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;divide-and-conquer&#34;&gt;Divide and conquer&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a way to instruct &amp;ldquo;simple&amp;rdquo; solver to solve a complex problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img data-src=&#34;Minion.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img data-src=&#34;office-messy-desk.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;divide-and-conquer-and-combine&#34;&gt;Divide and conquer (and combine)&lt;/h1&gt;

&lt;p&gt;Divide:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a problem $P$, the division of a problem is a procedure
that produces a collection of &lt;em&gt;smaller&lt;/em&gt; problems &lt;code&gt;$\mathbf{Q} = \{Q_1, Q_2, \dots\}$&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Conquer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each sub-problem &lt;code&gt;$Q_i\in\mathbf{Q}$&lt;/code&gt; (hopefully) is easier to solve.
Let &lt;code&gt;$S_i = \mathrm{solve}(Q_i)$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hopefully, the solutions of subproblems, ${S_i}$, are not useless toward the
solution of $P$.&lt;/p&gt;

&lt;p&gt;We need a procedure to combine:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\mathrm{solve}(P) = \mathrm{combine}(S_1, S_2, S_3, \dots)$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;example-cleaning-a-mess&#34;&gt;Example: cleaning a mess&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;Minion.jpg&#34; style=&#34;float:left;width:80px;margin:0 20px 0px 0&#34;&gt;&lt;/img&gt;
Consider how you can instruct a minion to clean a messy office.  The minion
is overwhelmed by the mess of the entire office.  Divide and conquer is a great
way to solve the cleaning problem.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here are some assumptions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The minion can clean up a very small section of an office - like a drawer, or
a book shelf.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If every section of an office is organized, we deem the whole office
organized.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;example-cleaning-a-mess-1&#34;&gt;Example: cleaning a mess&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide(Office) = &lt;code&gt;{Bookshelf, Desk, Floor, Cabinet, Drawer, $\dots$}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conquer: the minion can clean up each section&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combine: Nothing needs to be done&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Divide &amp;amp; Conquer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A list of numbers can be divided into smaller lists.
If a list is so small, we can sort it trivially.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How small does a list need to be for us to know how to sort it?&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer-1&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If we have two lists that are already sorted, can we figure out how to combine
them in a sorted way?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;+---+---+---+---+
| 1 | 5 | 6 | 8 |          \
+---+---+---+---+          |
                           |
                           +------&amp;gt;  combined sorted list
                           |
+---+---+---+---+----+     |
| 3 | 4 | 5 | 8 | 10 |     /
+---+---+---+---+----+
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer-2&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 10:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def merge(list1, list2):
    i, j = 0, 0
    list3 = []

    while i &amp;lt; len(list1) and j &amp;lt; len(list2):
        if list1[i] &amp;lt;= list2[j]:
            list3.append(list1[i])
            i += 1
        else:
            list3.append(list2[j])
            j += 1

    if i &amp;lt; len(list1): list3.extend(list1[i:])

    if j &amp;lt; len(list2): list3.extend(list2[j:])

    return list3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We want to be able to merge to sorted list into a larger list.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/kenpu/df50d5b42ed4abb0c4749284111005d6.js?file=merge.py&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;bottom-up-mergesort&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;bottom-up-mergesort-1&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;p&gt;We start with a list of arbitrary lenght $n$.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Observe that &lt;em&gt;all&lt;/em&gt; sublist of length 1 is already sorted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;merge()&lt;/code&gt; to improve the &lt;em&gt;sortedness&lt;/em&gt; of the list to length 2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;merge()&lt;/code&gt; to improve the &lt;em&gt;sortedness&lt;/em&gt; of the list to length 4, 8, 16, &amp;hellip;
until the whole list is sorted.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;bottom-up-mergesort-2&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bottom-up-mergesort-3&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;script src=&#34;//gist.github.com/kenpu/df50d5b42ed4abb0c4749284111005d6.js?file=mergesort.py&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;bottom-up-mergesort-4&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A hierarchy of subproblems&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Small subproblems: sublist of length 1&lt;/p&gt;

&lt;p&gt;Larger subproblems: sublist of length 2, 4, &amp;hellip;&lt;/p&gt;

&lt;p&gt;The largest subproblem: the whole list&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Why is it called &lt;em&gt;bottom-up&lt;/em&gt;?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The procedure, &lt;code&gt;mergesort()&lt;/code&gt;, recognizes the smallest subproblems &lt;em&gt;first&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;divide&lt;/strong&gt; stage starts at the bottom of the hierarchy.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;conquer&lt;/strong&gt; stage &lt;em&gt;always&lt;/em&gt; starts with the bottom of the hierarchy.&lt;/p&gt;

&lt;h1 id=&#34;analysis-correctness&#34;&gt;Analysis: correctness&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Loop-invariance:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At the end of each loop,&lt;/p&gt;

&lt;p&gt;for all $L[i\Delta \dots (i+1)\Delta]$ is sorted for all $i$,
where $\Delta$ is the sortedness at the end of the iteration.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Overall correctness&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The loop terminates when $\Delta$ exceeds the length of the list, so the
entire list is sorted by the loop invariance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Guaranteed termination&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration strictly increases the sortedness $\Delta$ (by doubling it).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;analysis-performance&#34;&gt;Analysis: performance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;How many iterations if there are $n$ elements in the list?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration grows the &lt;em&gt;sortedness&lt;/em&gt; by a factor of 2 up to $n$.
So, we need $\log_2(n)$ iterations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How many instructions does each iteration take?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration has four steps.  Each step requires no more than a linear scan
of the list.
We can guarantee that number of instructions do not exceed: $k\cdot n$ for some
constant $k$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Putting it together:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mergesort()&lt;/code&gt; requires no more than $k\cdot n\log(n)$ number of instructions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;top-down-mergesort&#34;&gt;Top-down mergesort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;top-down-mergesort-1&#34;&gt;Top-down mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Revisit the hierarchy of subproblems of sorting a list&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can specify the &lt;em&gt;Divide-and-conquer&lt;/em&gt; top-down:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Divide sorting of $L$ to the first sublist $L[0 \dots \frac{n}{2}]$
and the second sublist $L[\frac{n}{2} \dots n]$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the sub-lists are not easy enough, then break down again.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Recursion&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;top-down-mergesort-analysis&#34;&gt;Top-down mergesort: Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;correctness&#34;&gt;Correctness:&lt;/h2&gt;

&lt;p&gt;Induction on depth of recursion.&lt;/p&gt;

&lt;p&gt;Base case: depth = 0&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If there is no recursion, than the list $L$ is such that $|L|\leq 1$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Inductive case: depth = $k$, and assume that all mergesort at level $&amp;lt; k$ are
correct.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Let $L_1$ and $L_2$ be the two sublists.  The invocations &lt;code&gt;mergesort($L_i$)&lt;/code&gt;
use $&amp;lt; k$ recursions, and thus, are &lt;em&gt;correct&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Since $L_1$ and $L_2$ are properly sorted, and that &lt;code&gt;merge()&lt;/code&gt; is correct,
we conclude that &lt;code&gt;mergesort(L)&lt;/code&gt; is correct.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;top-down-mergesort-analysis-1&#34;&gt;Top-down mergesort: Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;performance&#34;&gt;Performance&lt;/h2&gt;

&lt;p&gt;Let $n = |L|$.  How much time does it take to complete top-down
&lt;code&gt;mergesort($L$)&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Let $T(n)$ = time of &lt;code&gt;mergesort($L$)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray*}
T(n) &amp;amp;\simeq&amp;amp; T(n/2) + T(n/2) + n \\
  &amp;amp;=&amp;amp; 2 T(n/2) + n
\end{eqnarray*}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will develop an array of techniques to solve &lt;em&gt;recurrence equations&lt;/em&gt; to
analyze recursive algorithms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Spoiler Alert:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$$ T(n) = n\log(n) + n $$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide and conquer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bottom-up mergesort&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Top-down mergesort&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is &lt;code&gt;MERGESORT&lt;/code&gt; a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/algorithms/optimal-sorting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/optimal-sorting/</guid>
      <description>

&lt;h1 id=&#34;optimal-comparison-based-sorting-br-v-s-br-numerical-sorting&#34;&gt;Optimal Comparison Based Sorting &lt;br&gt; v.s. &lt;br&gt;  Numerical Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Assumption&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elements in the array are &lt;em&gt;black boxes&lt;/em&gt;, and only comparison can be made between two elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;The decision-tree model&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a sorting algorithm $A$, we record &lt;em&gt;all&lt;/em&gt; possible comparison operations executed in $A$.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; A comparison operation: $(i,j)$ where $i, j$ are the &lt;em&gt;original&lt;/em&gt; index of the elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The leaf records the final ordering of the original index.&lt;/p&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting-1&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How many comparison operations did $A$ take as illustrated in the diagram?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the worst case number of comparision operations?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting-2&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What type of tree is the deicion tree?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Binary tree&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How many leaf nodes are there for $n$ elements?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All possible permutations of $[1, 2, 3, \dots n] = n!$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the height of the tree if there are $n!$ leaf nodes?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$\log_2(n!) \approx c\cdot n\log(n)$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;optimal-comparison-based-sorting&#34;&gt;Optimal Comparison Based Sorting&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Any comparision based sorting algorithm will necessarily take at least $c n\log(n)$ number of comparison operations in the &lt;em&gt;worst&lt;/em&gt; case.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Optimal sorting&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a comparison based sorting algorithm always makes at most $c n\log(n)$ number of comparisons, then it&amp;rsquo;s called &lt;em&gt;optimal&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;optimal-comparison-based-sorting-1&#34;&gt;Optimal Comparison Based Sorting&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Algorithm&lt;/th&gt;
&lt;th&gt;Optimal?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Insertion sort&lt;/td&gt;
&lt;td&gt;No, $n^2$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Mergesort&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Quicksort&lt;/td&gt;
&lt;td&gt;No, $n^2$ in the worst case&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sorting-integers&#34;&gt;Sorting Integers&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If an array contains (bounded) integers, we can beat optimal comparison based sorting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Why?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Elements are not blackboxes.  We can look at individual digits of an bounded integer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;counting-sort&#34;&gt;Counting sort&lt;/h1&gt;

&lt;p&gt;Assumptions:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The elements are integers.&lt;/li&gt;
&lt;li&gt;The elements are all in the range of $[0, k-1]$ for some $k \geq 0$.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Amazing fact:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;With $n$ elements, we can do it with only $2\cdot(n+k)$ number of instructions,
compare to $n\log(n)$ in the case of optimal comparison sorting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;counting-sort-1&#34;&gt;Counting sort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def empty_array(size, init=None):
    return [init for i in range(size)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; allocate an empty array with an optional initial value.&lt;/p&gt;

&lt;h1 id=&#34;counting-sort-2&#34;&gt;Counting sort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def COUNTING_SORT(A):
    n = len(A)
    k = max(A) + 1
    B = empty_array(size=n)
    C = empty_array(size=k, init=0)

    for a in A:
        C[a] = C[a] + 1

    for i in range(1,k):
        C[i] = C[i] + C[i-1]

    for a in reversed(A):
        B[C[a]-1] = a
        C[a] = C[a] - 1

    return B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;We compute the frequency of each distinct value in &lt;code&gt;A&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The frequence is then turned into cummulative frequency.  Namely:
&lt;code&gt;$C[x] = |\{y\in A: y\leq x\}|$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;With $C$, we can quickly deduce which each element should be positioned.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;counting-sort-3&#34;&gt;Counting Sort&lt;/h1&gt;

&lt;p&gt;Question:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is &lt;code&gt;COUNTING_SORT&lt;/code&gt; stable?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Answer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes.  It&amp;rsquo;s crucial to place $x$ into &lt;code&gt;B&lt;/code&gt; from &lt;code&gt;reverse(A)&lt;/code&gt; instead of &lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The best comparison sorting algorithms are in the order of $n\log(n)$.&lt;/li&gt;
&lt;li&gt;The best integer comparison algorithms can achieve the efficiency in the order of $n$.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COUNTING_SORT&lt;/code&gt; requires too much memory in practice to be applied to arrays with large integer values.  However, it will be instrumental later (as part of radix sort).&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;The measure of algorithmic efficiency will be made much more rigorous in the next section of this course.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/algorithms/quicksort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/quicksort/</guid>
      <description>

&lt;h1 id=&#34;quicksort&#34;&gt;Quicksort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;quicksort-1&#34;&gt;Quicksort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide and conquer&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a list $L$, we divide the sorting problem into two sub-problems.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Sort the elements in $L$ smaller than $x$: $L_1$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sort the elements in $L$ larger than $x$: $L_2$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combine&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$\mathrm{sorted}(L) = \mathrm{sorted}(L_1) \oplus \{x\} \oplus \mathrm{sorted}(L_2)$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;partition&#34;&gt;Partition&lt;/h1&gt;

&lt;p&gt;Given a list &lt;code&gt;$L$&lt;/code&gt; and an element $x$ in $L$, &lt;em&gt;partitioning&lt;/em&gt; $L[p \dots r]$ by the &lt;em&gt;pivot&lt;/em&gt;
element $x$ does the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rearrange the elements in $L[p\dots r]$ so that there exists a position $q$
such that &lt;em&gt;after&lt;/em&gt; rearrangment:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$L[q] = x$&lt;/li&gt;
&lt;li&gt;$\forall i\in [p, q-1],\ L[i] \leq x$&lt;/li&gt;
&lt;li&gt;$\forall i\in [q+1, r],\ L[i] \geq x$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;version-0-1-simple-but-takes-more-memory&#34;&gt;Version 0.1: simple, but takes more memory&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s implement &lt;code&gt;partition(L, p, r)&lt;/code&gt; with the minimal effort:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pick $x = L[r]$&lt;/li&gt;
&lt;li&gt;Filter the list for smaller elements: &lt;code&gt;$L_1 = \{y\in L[p\dots r-1]: y\leq x\}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Filter the list for larger elements: &lt;code&gt;$L_2 = \{y\in L[p\dots r-1]: y &amp;gt; x\}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reconstruct: &lt;code&gt;$L[p \dots r] = L_1 \oplus \{x\} \oplus L_2$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def partition(L, p, r):
    x = L[r]
    L1 = [y for y in L[p:r] if y &amp;lt;= x]
    L2 = [y for y in L[p:r] if y &amp;gt; x]
    L[p:r+1] = L1 + [x] + L2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;version-0-2-more-involved-but-takes-no-additional-memory&#34;&gt;Version 0.2: more involved, but takes no additional memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It only involves element swapping, so it requires &lt;em&gt;zero&lt;/em&gt; additional memory.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;But its correctness is much less obvious.&lt;/p&gt;

&lt;h1 id=&#34;analysis-of-partition&#34;&gt;Analysis of partition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bookkeeping is the key:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;$p$ and $r$ are the boundaries of the sublist to be partitioned.&lt;/li&gt;
&lt;li&gt;$r$ also holds the value of the pivot element.&lt;/li&gt;
&lt;li&gt;Elements in $[p\dots j]$ are processed.&lt;/li&gt;
&lt;li&gt;$i$ is a marker of the boundary between smaller and larger elements.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;analysis-of-partition-1&#34;&gt;Analysis of partition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Loop invariance:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;After each iteration, $L[p, j]$ is properly partitioned:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$L[p, i] \leq x$&lt;/li&gt;
&lt;li&gt;$L[i+1, j] &amp;gt; x$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;quicksort-2&#34;&gt;Quicksort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def quicksort(L, p, r):
    if p &amp;lt; r:
        k = partition(L, p, r)
        quicksort(L, p, k-1)
        quicksort(L, k+1, r)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;performance-analysis&#34;&gt;Performance Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will only give a terse outline of the analysis.  The full version is deferred to later lectures.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;performance-analysis-1&#34;&gt;Performance Analysis&lt;/h1&gt;

&lt;p&gt;Let there be $n$ elements in the array.&lt;/p&gt;

&lt;p&gt;Key obsevation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;partition(L, p, r)&lt;/code&gt; takes $(r - p)$ iterations.  Each iteration has a fixed number of instructions.  So, $T_\mathrm{partition} = c_1 (r-p) \leq c\cdot n$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;At each &lt;em&gt;invocation&lt;/em&gt; of &lt;code&gt;quicksort(L, p, k-1)&lt;/code&gt; and &lt;code&gt;quicksort(L, k+1, r)&lt;/code&gt;, we need to determine the number of elements: $k-1-p$, and $r-k-1$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;performance-analysis-worst-case&#34;&gt;Performance Analysis: Worst-case&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The worst case for $T_\mathrm{partition} = n$&lt;/li&gt;
&lt;li&gt;The worst case for $k-1-p = n-1$&lt;/li&gt;
&lt;li&gt;The worst case for $r-k-1 = n-1$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;We have enough to set-up an equation to estimate the number of instructions of &lt;code&gt;quicksort(L, a, b)&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;Let $|L[a\dots b]| = n$.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\begin{eqnarray}
T_\mathrm{quicksort}(n) &amp;amp;=&amp;amp; n + 2\cdot T_\mathrm{quicksort}(n-1)
\end{eqnarray}$$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This leads to a (poor) performance characteristics of: $\approx n^2$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will show how to solve such equations (known as recurrence equations) in the next section of this course.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;performance-analysis-average-case&#34;&gt;Performance Analysis: average case&lt;/h1&gt;

&lt;p&gt;Quicksort as the name suggests is actually quite quick (most of the time&amp;hellip;)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Revisiting &lt;code&gt;k = partition(L, p, q)&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The pivot value should be somewhere in the middle of the subarray.
Namely: $k\approx p+q/2$, and so $k-1-p \approx n/2$, and $q-k-1\approx n/2$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Revisiting the recurrence equation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\begin{eqnarray}
T_\mathrm{quicksort}(n) &amp;amp;=&amp;amp; n + 2\cdot T_\mathrm{quicksort}(n/2)
\end{eqnarray}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;This leads to a satisfying performance characteristics of: $\approx n\log(n)$&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Partition: a simple version&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Partition: a zero-memory version&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Quicksort: a recursive sorting algorithm&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is &lt;code&gt;QUICKSORT&lt;/code&gt; a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/programming-languages/functional-computation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/functional-computation/</guid>
      <description>

&lt;h1 id=&#34;lambda-calculus-symbolic-computation&#34;&gt;$\lambda$-Calculus: symbolic computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lambda-calculus&#34;&gt;$\lambda$-Calculus&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Proposed by Alonzo Church in ~1930.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;intented to formalize mathematics.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Syntactic expressions that represent &lt;em&gt;functions&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;designed to represent the entire foundation of mathematics.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Rules of rewriting the syntactic expression&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;rewrite rules represent mathematical reasoning.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;expressions&#34;&gt;Expressions&lt;/h1&gt;

&lt;p&gt;Values&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Literals: 1, 2, 3, &amp;ldquo;Hello world&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Variables: $x, y, z, \dots$&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Functions&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$+ : (x,y)\mapsto x+y$&lt;/li&gt;
&lt;li&gt;$\mathrm{inc} : x\mapsto x+1$&lt;/li&gt;
&lt;li&gt;$\dots$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Always returns &lt;em&gt;one&lt;/em&gt; value.&lt;/li&gt;
&lt;li&gt;Takes a fixed number of inputs: arity of the function
&lt;span style=color:red&gt;*&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;value-as-function&#34;&gt;Value as function&lt;/h1&gt;

&lt;p&gt;A value is a zero-arity function.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;function-as-value&#34;&gt;Function as value&lt;/h1&gt;

&lt;p&gt;We want to extend the idea of &lt;em&gt;things&lt;/em&gt; to include functions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;This is a central idea in functional programming&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;value-equiv-function-everything&#34;&gt;Value $\equiv$ Function = Everything&lt;/h2&gt;

&lt;h1 id=&#34;syntax-for-expressions-value-function&#34;&gt;Syntax for expressions (value / function)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$x, y, z, \dots$ are expressions&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Abstraction:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;If $x$ is a variable, and $e$ is an expression, then
$\lambda x. e$ is an expression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Application:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;If $e_1$ is a function with arity 1,
&lt;code&gt;$e_2$&lt;/code&gt; is an expression, then
$e_1 e_2$ is an expression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We assume that all functions are with arity 1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is not a restriction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;the-weird-syntax-of-lambda-calculus&#34;&gt;The &lt;em&gt;weird&lt;/em&gt; syntax of $\lambda$ calculus&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$\lambda x.e$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is a function taking &lt;em&gt;one&lt;/em&gt; input, represented by the variable $x$.
It returns &lt;em&gt;one&lt;/em&gt; value, which is evaluated as the expression $e$.
The expression $e$ usually makes uses of $x$, but not necessarily.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$e_1 e_2$&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is passing $e_2$ as an argument to the expression $e_1$.  Recall that
everything is a function.  So $e_1$ is a function with &lt;em&gt;one&lt;/em&gt; argument.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$e_1 e_2 e_3 = ((e_1 e_2) e_3)$&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This shows that $e_1$ takes one argument ($e_2$), and returns an
expression which is yet again a function which takes $e_3$ as an input.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;defining-things&#34;&gt;Defining things&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Identity function&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$\lambda x.x$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Functions with multiple arity&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose we have a function $f(x,y,z) = e$ where the expression
involves all three input variables $x, y, z$.&lt;/p&gt;

&lt;p&gt;We can use the following expression to build $f$:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$\lambda x.(\lambda y.(\lambda z. e))$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;This is a big deal.&lt;/strong&gt; &lt;br&gt;
&lt;strong&gt;Functions as values in action here.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=height:220px&gt;&lt;/div&gt;

&lt;p&gt;We can write it conveniently as $\lambda xyz.e$&lt;/p&gt;

&lt;h1 id=&#34;computing-with-lambda-calculus&#34;&gt;Computing with $\lambda$-Calculus&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We rely on string-rewriting to evaluate
LC expressions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;substitution-of-variables-in-function-applications&#34;&gt;Substitution of variables in function applications&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Notation&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$e[x/e&amp;rsquo;]$ is the expression obtained by substituting all occurances of $x$ in
the expression $e$ with the expression $e&amp;rsquo;$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Substition&lt;/strong&gt; as a way to evaluate function application:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$(\lambda x. e) e&amp;rsquo; \implies e[x/e&amp;rsquo;]$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray}
&amp;amp;&amp;amp; (\lambda x.x x) (\lambda y. y) \\
&amp;amp;\implies&amp;amp; (x x)[x/(\lambda y.y)] \\
&amp;amp;\implies&amp;amp; (\lambda y.y)(\lambda y.y) \\
&amp;amp;\implies&amp;amp; y[y/(\lambda y.y)] \\
&amp;amp;\implies&amp;amp; (\lambda y.y)
\end{eqnarray}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We can easily get into trouble.&lt;/p&gt;

&lt;p&gt;Substitution cannot be used freely.&lt;/p&gt;

&lt;h1 id=&#34;free-bound-variables&#34;&gt;Free &amp;amp; Bound Variables&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Variables in a function abstraction expression can be &lt;em&gt;free&lt;/em&gt; or &lt;em&gt;bound&lt;/em&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a variable represents the input parameter in a function expression, then
it&amp;rsquo;s considered &lt;em&gt;bound&lt;/em&gt;.  Otherwise, it&amp;rsquo;s &lt;em&gt;free&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;$\mathbf{FV}(e)$ are the free variables of $e$&lt;/li&gt;
&lt;li&gt;$\mathbf{BV}(e)$ are the bound variables&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;variable-capturing&#34;&gt;Variable Capturing&lt;/h1&gt;

&lt;p&gt;Consider an expression:&lt;/p&gt;

&lt;p&gt;$$\lambda x. (\lambda x.x)$$&lt;/p&gt;

&lt;p&gt;There are multiple occurrences of $x$, so let&amp;rsquo;s label them so we can refer to
the individual occurrences.&lt;/p&gt;

&lt;p&gt;$$\lambda x_1. (\lambda x_2.x_3)$$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Which input variable does $x_3$ refer to?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; This is called capturing.&lt;/p&gt;

&lt;h1 id=&#34;elimination-of-variable-capturing&#34;&gt;Elimination of Variable Capturing&lt;/h1&gt;

&lt;p&gt;There is a rewrite rule that allows us to rename the parameter variables without
changing the meaning of the expression.&lt;/p&gt;

&lt;p&gt;$$ \lambda x. x \equiv \lambda y.y \equiv \lambda \mathsf{hello}.\mathsf{hello} $$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Renaming&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose that $x$ is a free variable of $e$, and $y$ does not appear in $e$ at
all.&lt;/p&gt;

&lt;p&gt;Then $\lambda x.e \implies \lambda y.e[x/y]$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;elimination-of-variable-capturing-1&#34;&gt;Elimination of Variable Capturing&lt;/h1&gt;

&lt;p&gt;Back to:&lt;/p&gt;

&lt;p&gt;$$\lambda x. (\lambda x.x)$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;First we consider the sub expression $\lambda x.x$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Using renaming, we can rewrite it to $\lambda y.y$.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Then we get:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$$\lambda x. (\lambda x.x) \implies \lambda x.\lambda y. y$$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt;
Generally, we only apply &lt;strong&gt;substitution&lt;/strong&gt; to evaluate function applications
if there is &lt;em&gt;no&lt;/em&gt; variable capturing; and this can be achieved by &lt;strong&gt;renaming&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;how-to-perform-computation-using-lc&#34;&gt;How to perform computation using LC?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Natural numbers&lt;/li&gt;
&lt;li&gt;Arithmetics&lt;/li&gt;
&lt;li&gt;Loop and conditional branching&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;All can be done using LC&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Express the algorithm in terms of natural numbers, arithmetics,
 loops and conditional branches.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Encode the algorithm in LC.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Apply syntax rewriting until no more rewriting is possible.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;a-glance-of-lc-in-action&#34;&gt;A glance of LC in action&lt;/h1&gt;

&lt;p&gt;A bit of notation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$\lambda x.\lambda y. \lambda z. e$ is written as as $\lambda xyz. e$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Now we can encode numbers:&lt;/p&gt;

&lt;p&gt;$0 \equiv \lambda sx. x$ (takes two inputs, but only keep the second one.)&lt;/p&gt;

&lt;p&gt;$1 \equiv \lambda sx. sx$&lt;/p&gt;

&lt;p&gt;$2 \equiv \lambda sx. ssx$&lt;/p&gt;

&lt;p&gt;$\vdots$&lt;/p&gt;

&lt;h1 id=&#34;arithmetics&#34;&gt;Arithmetics&lt;/h1&gt;

&lt;p&gt;Consider the simplest arithmetics: increment by 1.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def succ(n):
    return n + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$S \equiv \lambda n. \lambda yx.y(nyx)$$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let&amp;rsquo;s try this out.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray}
S 0 &amp;amp;=&amp;amp; (\lambda n. \lambda yx.ynyx)0 \\
    &amp;amp;=&amp;amp; (\lambda yx.ynyx)[n/0] \\
    &amp;amp;=&amp;amp; \lambda yx.y(0yx) \\
    &amp;amp;=&amp;amp; \lambda yx.y((\lambda sz.z)yx) \\
    &amp;amp;=&amp;amp; \lambda yx.y(x) \\
    &amp;amp;=&amp;amp; 1
\end{eqnarray}&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;arithmetics-1&#34;&gt;Arithmetics&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add(n1, n2):
    return n1 + n2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Observe:&lt;/p&gt;

&lt;p&gt;$2 S 3 = 5$ (work it out, it&amp;rsquo;s quite incredible.)&lt;/p&gt;

&lt;p&gt;So, we have:&lt;/p&gt;

&lt;p&gt;$$+ \equiv \lambda mn. mSn$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Can you guess the LC expression for multiplication?&lt;/p&gt;

&lt;h1 id=&#34;recursion&#34;&gt;Recursion&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LC does not require assigning aliases to functions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Technically, there is just &lt;strong&gt;ONE&lt;/strong&gt; expression for the entire algorthm.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why it&amp;rsquo;s hard to do recursion without aliases?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def factorial(n):
    if n &amp;lt;= 1:
        return n
    else:
        return n * factorial(n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Is it even possible?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes.  It&amp;rsquo;s called the &lt;strong&gt;Y&lt;/strong&gt;-combinator.&lt;/p&gt;

&lt;p&gt;$$ \mathbf{Y} \equiv (\lambda y.(\lambda x.y(xx))(\lambda x.y(xx)))$$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;y-combinator&#34;&gt;Y-combinator&lt;/h1&gt;

&lt;p&gt;$$ \mathbf{Y} f = f (\mathbf{Y} f) $$&lt;/p&gt;

&lt;p&gt;So,&lt;/p&gt;

&lt;p&gt;$$ \mathbf{Y} f x \implies f (\mathbf{Y} f) x \implies f f \dots f x $$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; $\mathbf{Y} f$ is a &lt;em&gt;fixed point&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;using-y-combinator-to-implement-factorial&#34;&gt;Using Y-combinator to implement factorial&lt;/h1&gt;

&lt;p&gt;Consider a function $F$ as:&lt;/p&gt;

&lt;p&gt;$$\lambda fx. (\mathrm{ifzero}\ x)\ 1\ (*\ x\ (f\ (\mathrm{dec}\ x)))$$&lt;/p&gt;

&lt;p&gt;If we apply the Y-combinator to $F$, we get:&lt;/p&gt;

&lt;p&gt;$$ (\mathbf{Y} F) n = F (\mathbf{Y} F) n $$&lt;/p&gt;

&lt;p&gt;You can check the following:&lt;/p&gt;

&lt;p&gt;$$ (\mathbf{Y} F) n = (\mathrm{ifzero}\ n)\ 1\ (*\ n\ ((\mathbf{Y} F)\ (\mathrm{dec}\ n))) $$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is really quite amazing.  We have achieved Turing-completeness via recursion.  The amazing part is that we don&amp;rsquo;t need variables to refer to any values.  So $F$ is just for convenience and readability.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LC is purely symbolic.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It carries out computation by very simple string rewrites:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Function application&lt;/li&gt;
&lt;li&gt;Variable renaming&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It solves problem by:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Encode the problem as a single (huge) string of LC expression.&lt;/li&gt;
&lt;li&gt;Using the rules to rewrite the string to a &lt;em&gt;normal&lt;/em&gt; form.&lt;/li&gt;
&lt;li&gt;The resulting LC expression is the answer.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No variables are needed.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/programming-languages/old/intro-to-languages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/old/intro-to-languages/</guid>
      <description>

&lt;h1 id=&#34;computation-in-practice&#34;&gt;Computation in practice&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Languages based on stateful computation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Languages based on functional computation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hybrid languages&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;stateful-computation&#34;&gt;Stateful computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Languages&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Javascript&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Task&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Quicksort&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;X = [6, 3, 4, 8, 1, 4]

def quicksort(X, i, j):
  if i &amp;lt; j:
    p = partition(X, i, j)
    quicksort(X, i, p-1)
    quicksort(X, p+1, j)

def partition(X, i, j):
  pivot = X[j]
  m = i
  for n in range(i, j):
    if X[n] &amp;lt;= pivot:
      X[m], X[n] = X[n], X[m]
      m += 1
  X[m], X[j] = X[j], X[m]
  return m

def QuickSort(X):
  return quicksort(X, 0, len(X)-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;breakdown-of-python&#34;&gt;Breakdown of python&lt;/h1&gt;

&lt;div pdf=&#34;qsort-py.pdf&#34; scale=0.8&gt;&lt;/div&gt;

&lt;h1 id=&#34;python-v-s-javascript&#34;&gt;Python v.s. Javascript&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;script
src=&#34;https://gist.github.com/kenpu/e2e3fcc9feea16fb14a84c7ec98cdd75.js?file=qsort.py&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=height:600px;overflow:auto&gt;
&lt;script
src=&#34;https://gist.github.com/kenpu/e2e3fcc9feea16fb14a84c7ec98cdd75.js?file=qsort.js&#34;&gt;&lt;/script&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/courses/programming-languages/stateful-computation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/stateful-computation/</guid>
      <description>

&lt;h1 id=&#34;computation-the-turing-machine&#34;&gt;Computation &amp;amp; the Turing Machine&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;computation&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;david-hilbert.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hilbert&amp;rsquo;s Ten&amp;rsquo;s problem, 1900&lt;/li&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-1&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;kurt-godel.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;Gödel&amp;rsquo;s incompleteness theorem&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-2&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;alan-turing.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;Turing machine&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-3&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;alonzo-church.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;$\lambda$-calculus&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-4&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;john-von-neumann.jpg&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;von Neumann computing model&lt;/li&gt;
&lt;li&gt;EDVAC&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;turing-machine&#34;&gt;Turing Machine&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A completely mechanical device (1928)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;envisioned by Alan Turing as an intuitive formalism to
describe the non-existing phenomenon of machine driven
reasoning, now known as &lt;em&gt;computation&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Realized into an actual design (1945)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;John von Neumann designed an electronic version to simulate
the mechanical definition of a TM in a document known as &lt;em&gt;First Draft of a
Report on the EDVAC&lt;/em&gt;, 1945.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Turing-complete&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TM is the most powerful computing model we know.
Up to now, we don&amp;rsquo;t know any other computing models more powerful than
a TM.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;turing-machine-1&#34;&gt;Turing Machine&lt;/h1&gt;

&lt;div pdf=&#34;turing-machine.pdf&#34; scale=0.8&gt;&lt;/div&gt;

&lt;h1 id=&#34;computational-power-of-tm&#34;&gt;Computational power of TM&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Church-Turing Thesis&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a procedure (algorithm) can be executed by &lt;em&gt;any&lt;/em&gt; computer, then it can be
executed by a Turing Machine.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Turing Complete&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a mechanism is equivalent to TM, then it&amp;rsquo;s called &lt;em&gt;Turing Complete&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;simulation-of-a-function&#34;&gt;Simulation of a function&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Computable functions&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A function $f$ is computable if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Its input can be encoded as a binary string: &lt;code&gt;$2^*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Its output can be encoded as a binary string: &lt;code&gt;$2^*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Its evaluation can always be carried out by a TM.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Any computable function can be implemented by a TM.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any TM is some computable function.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Why is a TM always a function (over binary strings)?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;universal-tm&#34;&gt;Universal TM&lt;/h1&gt;

&lt;p&gt;Consider a TM: $M$.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s a function &lt;code&gt;$M:2^*\to 2^*$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s mechanical description can be encoded as a binary string.
&lt;i style=&#34;font-size:200%;color:#faa;vertical-align:middle;margin-left:10px&#34; class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Function &lt;em&gt;eval&lt;/em&gt; takes two inputs - a TM and an input, and it computes the
output.&lt;/p&gt;

&lt;p&gt;$$\mathrm{eval} :\mathrm{TM} \times 2^* \to 2^*$$&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s input can be encoded as binary strings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It can be carried out by a procedure.
&lt;i style=&#34;font-size:200%;color:#faa;vertical-align:middle;margin-left:10px&#34; class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By Church-Turing thesis, &lt;strong&gt;eval&lt;/strong&gt; is computable, so there is a TM for it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Definition&lt;/em&gt; &lt;strong&gt;Universal TM&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The TM $\mathbf{U}$ that computes &lt;strong&gt;eval&lt;/strong&gt; is called &lt;em&gt;universal&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;universal-tm-1&#34;&gt;Universal TM&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The TM $\mathbf{U}$ initializes the tape with the binary encoding of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a TM, $M$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;an input, $x$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It outputs $\mathbf{eval}(M, x)$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Modern Computer:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$M$ is the program&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$x$ is the input to the program&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\mathbf{U}$ is the general purpose computer&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tm-programming&#34;&gt;TM-Programming&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We just need a single TM, namely $\mathbf{U}$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The universal programming language is the encoding of $M$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Turing Machine is a mechanically realizable device.&lt;/li&gt;
&lt;li&gt;TM is as powerful (but a lot slower) as any modern computers.&lt;/li&gt;
&lt;li&gt;There is a very special TM that is called the &lt;em&gt;Universal TM&lt;/em&gt;.  It can be
&lt;em&gt;programmed&lt;/em&gt;!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/people/kenpu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/people/kenpu/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Ken Pu&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Associate Professor &lt;br&gt;
&lt;a href=&#34;http://www.science.uoit.ca/undergraduate/programs-and-information-for-prospective-students/computing-science/&#34;&gt;Computer Science&lt;/a&gt; /
&lt;a href=&#34;http://science.uoit.ca&#34;&gt;Faculty of Science, UOIT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Contact&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Email: &lt;code&gt;ken.pu@uoit.ca&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Address:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Faculty of Science, 2000 Simcoe Street North, Oshawa ON, L1H 7K3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Office and telephone:
&lt;a href=&#34;https://ssbp.mycampus.ca/prod/www_directory.directory_uoit.p_ShowPeople?first_name_in=ken&amp;amp;last_name_in=pu&amp;amp;button_text_in=Search&#34;&gt;See here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kenpuca.github.io/sandbox/slide/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/sandbox/slide/</guid>
      <description>

&lt;h1 id=&#34;hello&#34;&gt;Hello&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(println &amp;quot;hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;



&lt;iframe 
    
    data-src=&#39;http://db.science.uoit.ca:8080/?arg=kenpu/clojure&#39;
    
    style=&#39;max-width:100%;width:100%;height:400px&#39;&gt;&lt;/iframe&gt;


</description>
    </item>
    
    <item>
      <title>Algorithms</title>
      <link>https://kenpuca.github.io/courses/algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/</guid>
      <description>&lt;div class=&#34;jumbotron&#34;&gt;
	&lt;h1&gt;Design &amp; Analysis of Algorithms&lt;/h1&gt;
&lt;/div&gt;

&lt;div class=row&gt;
	&lt;div class=col-md-3&gt;
		&lt;img src=&#34;textbook.jpg&#34; width=100%&gt;&lt;/img&gt;
		&lt;figcaption&gt;
	    Introduction to Algorithms, Third Edition,
	    &lt;i&gt;Coremen, Leiserson, Rivest and Stein&lt;/i&gt;
	    &lt;/figcaption&gt;
	    &lt;p style=margin-top:10px;font-style:italic;font-size:90%&gt;
			This course is about problem solving and computation via algorithms.
			We will cover a number of known algorithms (sorting, hashing, search,
			indexing) and their applications.  We will discuss methods for analyzing
			existing algorithms and designing new algorithms.
			Finally, the students will be introduced to &lt;i&gt;complexity classes&lt;/i&gt;, in
			particular the class of &lt;i&gt;NP-completeness&lt;/i&gt;.
		&lt;/p&gt;

	&lt;/div&gt;
	&lt;div class=col-md-9&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Sorting&lt;/h1&gt;
				&lt;p&gt; Chapter 2.1, 2.3, 6, 7, 8&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;insert-sort&#34;&gt;Insertion sort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;merge-sort&#34;&gt;Mergesort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;quicksort&#34;&gt;Quicksort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;
						&lt;a href=&#34;optimal-sorting&#34;&gt;
							Comparision based sorting versus numeric sorting
						&lt;/a&gt;
					&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;sorting-numbers&#34;&gt;Sorting integers&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Analysis of Complexity&lt;/h1&gt;
				&lt;p&gt; Chapter 3, 4, 5&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;
						&lt;a href=&#34;big-o&#34;&gt;Asymptotic notations&lt;/a&gt;
						&lt;span style=&#34;float:right&#34; class=&#34;label label-warning&#34;&gt;DRAFT&lt;/span&gt;
					&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Recurrence equations&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Probabilistic analysis of randomized algorithms&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Data structures&lt;/h1&gt;
				&lt;p&gt;Chapter 10, 11, 12&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Elementary data structures&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Hash tables&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Trees&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Optimization&lt;/h1&gt;
				&lt;p&gt;Chapter 15, 16&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Dynamic programming&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Greedy algorithms&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Huffman codes&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Graphs&lt;/h1&gt;
				&lt;p&gt;Chapter 22, 23, 24, 25, 26&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Graph search&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Spanning trees&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Shortest path algorithms&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Maxflow&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Complexity &amp; Tractability&lt;/h1&gt;
				&lt;p&gt;Chapter 34&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Decision problems&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;P, NP and reduction&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;NP-complete and other complexity classes&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Computability&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

	&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt; a[href=&#34;&#34;] {color: #888;} &lt;/style&gt;
</description>
    </item>
    
    <item>
      <title>Asymptotic notation</title>
      <link>https://kenpuca.github.io/courses/algorithms/big-o/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/big-o/</guid>
      <description>

&lt;h1 id=&#34;asymptotic-notation&#34;&gt;Asymptotic notation&lt;/h1&gt;

&lt;p&gt;We will develop a way to measure the efficiency of algorithms which is &lt;em&gt;invariant&lt;/em&gt; to the non-essential issues such as the speed of computer hardware and the effiency of the programming language used.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The measurement functions is only sensitive to the &lt;em&gt;growth&lt;/em&gt; of the time it takes for an algorithm to complete with respect to the size of the input.&lt;/p&gt;

&lt;h1 id=&#34;measure&#34;&gt;Measure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The size of the input is an integer $n$&lt;/li&gt;
&lt;li&gt;We use functions over integers to measure the efficiency of an algorithm.&lt;/li&gt;
&lt;li&gt;$f(n)$ is the &lt;strong&gt;time&lt;/strong&gt; it takes to process input of size $n$ in the &lt;em&gt;worst case&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;$f$ is monotonic: if $m \leq n$, then $f(m)\leq f(n)$.&lt;/li&gt;
&lt;li&gt;$f$ is strictly positive: $f(n) &amp;gt; 0$ for all $n$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;using-functions-as-measurement-of-algorithmic-complexity&#34;&gt;Using functions as measurement of algorithmic complexity&lt;/h1&gt;

&lt;p&gt;We want to use functions to measure the inherit &lt;em&gt;complexity&lt;/em&gt; of &lt;em&gt;algorithms&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is not very straight-forward.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We don&amp;rsquo;t care about&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Runtime environment&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU speed&lt;/li&gt;
&lt;li&gt;Start-up time of the program&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implementation issues&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Speed of the language&lt;/li&gt;
&lt;li&gt;Number of statements used&lt;/li&gt;
&lt;li&gt;Overhead in memory data structure&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We do care about&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inherit complexity of the algorithm&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;capturing-the-essentials&#34;&gt;Capturing the essentials&lt;/h1&gt;

&lt;p&gt;Suppose that we have an algorithm $P$.  Let&amp;rsquo;s use some function $f(n)$ to represent the time, in the &lt;em&gt;worst case&lt;/em&gt;, that $P$ takes to process an input of size $n$.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at the effects of various environmental factors on the measure $f(n)$.&lt;/p&gt;

&lt;h1 id=&#34;effects-on-the-measure&#34;&gt;Effects on the measure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$P$ is reimplemented using C (from Python), so it runs 20 times faster now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$f&amp;rsquo;(n) = \frac{1}{20} f(n)$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$P$ runs inside a &lt;em&gt;docker&lt;/em&gt; image, so it takes an additional 300 ms to start.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$f&amp;rsquo;(n) = f(n) + 300\mathrm{ms}$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But we don&amp;rsquo;t want to care about these implementation and runtime factors when investigating the complexity of algorithms.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Intuition: given $f(n)$, we define family of (infinite) functions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{better\ than}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{worse\ than}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{equivalent\ to}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;mathcal-o-notation-better-than&#34;&gt;$\mathcal{O}$-notation - better than&lt;/h1&gt;

&lt;p&gt;We want to define all function which are measure of algorithms which are better than (or same as) $g(n)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: The Big-O notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\mathcal{O}(g(n)) = \{f(n) : \exists n_0, c &amp;gt; 0,\forall n &amp;gt; n_0, \ 0 &amp;lt; f(n) &amp;lt; c\cdot g(n)\}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We call $g(n)$ the asymptotic upper bound of the functions in $\mathcal{O}(g(n))$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;big-o.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;significance-of-asymptotic-analysis&#34;&gt;Significance of asymptotic analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If we have an algorithm $A$, and its precise time measurement (on a specific hardware) is given precisely as &lt;code&gt;$T(n)$&lt;/code&gt;, where $n$ is the input size in &lt;em&gt;bytes&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If &lt;code&gt;$T(n)\in\mathcal{O}(g(n))$&lt;/code&gt;, we are saying that $A$ is &lt;strong&gt;better&lt;/strong&gt; than $g(n)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Challenge&lt;/em&gt;:&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Check that the variations on the way that the efficiency of $A$ is
measured also are in $\mathcal{O}(g(n))$.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$T_1(n)$ is the time that $A$ runs on a slow processor.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$T_2(n)$ is the time that $A$ if the input is measured in the array length.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;omega-notation-worse-than&#34;&gt;$\Omega$-notation - worse than&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: The $\Omega$-notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\Omega(g(n)) = \{f(n) : \exists n_0, c &amp;gt; 0,\forall n &amp;gt; n_0, \ 0  &amp;lt; c\cdot g(n) &amp;lt; f(n) \}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We say that $g(n)$ is the asymptotic lower bound of the functions in $\Omega(g(n))$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;omega.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;theta-notation-same-as&#34;&gt;$\Theta$-notation - same as&lt;/h1&gt;

&lt;p&gt;*&lt;em&gt;Definition&lt;/em&gt;: The $\Theta$-notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\Theta(g(n)) = \mathcal{O}(g(n)) \cap \Omega(g(n))$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;More precisely,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$
\begin{eqnarray}
&amp;amp;&amp;amp; \Theta(g(n)) \\
&amp;amp;=&amp;amp; 
\{f(n): \exists n_0, c_1, c_2 &amp;gt; 0,\forall n &amp;gt; n_0,\ 0 \leq c_1\cdot g(n) \leq f(n) \leq c_2\cdot g(n)\}
\end{eqnarray}
$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;theta.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;recap&#34;&gt;Recap&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$\mathcal{O}(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are better (or equivalent) to $g(n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\Omega(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are worse (or equivalent) to $g(n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\Theta(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are equivalent to $g(n)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;why-is&#34;&gt;Why is&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Bucket Sort</title>
      <link>https://kenpuca.github.io/courses/algorithms/bucket-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/algorithms/bucket-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Clojure Language</title>
      <link>https://kenpuca.github.io/courses/programming-languages/clojure-language-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/clojure-language-2/</guid>
      <description>

&lt;h1 id=&#34;clojure-part-ii&#34;&gt;Clojure: Part II&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We will be covering the &lt;em&gt;rest&lt;/em&gt; of the Clojure syntax.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Native data structures beyond just lists:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;vector&lt;/li&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;li&gt;hash-map&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Iteration and branching&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Functions and higher order functions&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Clojure: the language</title>
      <link>https://kenpuca.github.io/courses/programming-languages/clojure-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kenpuca.github.io/courses/programming-languages/clojure-language/</guid>
      <description>

&lt;h1 id=&#34;clojure-part-i&#34;&gt;Clojure: Part I&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Life cycle of Lisp code&lt;/li&gt;
&lt;li&gt;Raw basics&lt;/li&gt;
&lt;li&gt;Syntactic sugars&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;review-of-lisp&#34;&gt;Review of Lisp&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A program is a (nested) list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Not all lists are valid programs.  Only certain type of lists can be interpreted as programs.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Valid: &lt;code&gt;(+ 1 2 (* 3 5))&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Invalid: &lt;code&gt;(1 2 +)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sometimes the validity of a list depends on the dialect of Lisp:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;(defun add (a b) (+ a b))&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Valid for &lt;em&gt;Common Lisp&lt;/em&gt;, but not &lt;em&gt;Racket&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;(define (add a b) (+ a b))&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Valid for &lt;em&gt;Racket&lt;/em&gt;, but not &lt;em&gt;Common Lisp&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;lifecycle-of-lists-in-lisp&#34;&gt;Lifecycle of lists in Lisp&lt;/h1&gt;

&lt;p&gt;The unified representation of programs using a data structure that programs can manipulate, Lisp has a uniquely self-referencial nature that makes it exceedingly powerful (and intellectually challenging).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; &lt;i style=font-size:200%;vertical-align:middle class=&#34;fa fa-bolt&#34;&gt;&lt;/i&gt; Lisp rewrites itself, and it &lt;em&gt;grows&lt;/em&gt; by itself.&lt;/p&gt;

&lt;h1 id=&#34;two-phase-compilation&#34;&gt;Two-phase compilation&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;lisp-pre-expand.jpg&#34; alt=&#34;pre-expanded&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;note 3&#34;&gt;!&lt;/a&gt; During expansion, functions, known as &lt;em&gt;macros&lt;/em&gt;, evaluate certain fragments in the program.  These fragments are the extensions to the language.&lt;/p&gt;

&lt;h1 id=&#34;two-phase-compilation-1&#34;&gt;Two-phase compilation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;lisp-post-expand.jpg&#34; alt=&#34;post-expanded&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The macro functions converts the entire nested list to a valid Lisp program.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp sm&#34;&gt;(... (macro (quote (... invalid-list ...))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gets evaluated to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp sm&#34;&gt;(... (... valid-list ...))

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;core-clojure&#34;&gt;Core Clojure&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;List-only core syntax (low-level and verbose)&lt;/li&gt;
&lt;li&gt;(Sensible) syntactic extensions&lt;/li&gt;
&lt;li&gt;Tons of macros&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;clojure&#34;&gt;Clojure&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition:&lt;/strong&gt; (Atoms)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An &lt;em&gt;atom&lt;/em&gt; is a value that can be an element of a list.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go through the different atoms of the core-clojure langauge.&lt;/p&gt;

&lt;h1 id=&#34;numbers&#34;&gt;Numbers&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Numbers&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Long numbers&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3.1415&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ratio&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1/3&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BigInt&lt;/td&gt;
&lt;td&gt;10000N&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BigDecimal&lt;/td&gt;
&lt;td&gt;3.1415M&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;strings&#34;&gt;Strings&lt;/h1&gt;

&lt;p&gt;Simple strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Hello world.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;I say \&amp;quot;Hello\&amp;quot; to the world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiline string:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;&amp;quot;Hello,
This is a big world of long
sentences.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;character&#34;&gt;Character&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;\a
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;keywords&#34;&gt;Keywords&lt;/h1&gt;

&lt;p&gt;Keywords are a staple of Clojure programs.  They are quick and efficient way to create &lt;em&gt;constants&lt;/em&gt;.
They are similar to the Java &lt;code&gt;enum&lt;/code&gt; values.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Keywords have the same rule as variable names (aka &lt;em&gt;symbols&lt;/em&gt;), except they must start with &lt;code&gt;:&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:red
:blue
:green
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:big-red-apple
:blue-sky
:important-field!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Later, we will introduce namespaces.  Like symbols, keywords can be specialized by a namespace.&lt;/p&gt;

&lt;h1 id=&#34;symbols&#34;&gt;Symbols&lt;/h1&gt;

&lt;p&gt;Symbols are variables which are labels referring to some data or function.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; It&amp;rsquo;s natural to think of Clojure symbols as variables.  But Clojure can do &lt;em&gt;more&lt;/em&gt; with its symbols than other languages can do with variables.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Clojure has some very relaxed rules in naming symbols:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;a                 ; looks like a variable.
*a*               ; can have (almost) any characters except whitespaces
int-&amp;gt;float        ; good names can be extremely satisfying
java.lang/Integer ; a symbol that has a namespace &amp;quot;java.lang&amp;quot;, and name &amp;quot;Integer&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;more-about-symbols&#34;&gt;More about symbols&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Var&lt;/em&gt; s are symbols which represent other expressions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;a =&amp;gt; 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Almost) each time a &lt;em&gt;var&lt;/em&gt; appears, it is evaluated to its expression.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Other languages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In other programming languages, one can &lt;em&gt;only&lt;/em&gt; access the expression referred by variables.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lisp&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In Lisp, we can (and need) to access (and create) the variable &lt;em&gt;itself&lt;/em&gt; using Lisp.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(var a)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;beyond-parentheses-in-clojure&#34;&gt;Beyond parentheses in Clojure&lt;/h1&gt;

&lt;p&gt;Clojure uses other brackets to improve the parentheses overload.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(let ((a 10)
      (b 20))
  (+ a b))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Common Lisp&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [a 10
      b 20]
  (+ a b))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Clojure&lt;/p&gt;

&lt;h1 id=&#34;lambda-calculus-in-clojure&#34;&gt;Lambda Calculus in Clojure&lt;/h1&gt;

&lt;p&gt;We will focus on the core Clojure - which is a Turing-complete implementation of Lambda Calculus.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Function application&lt;/li&gt;
&lt;li&gt;Function abstraction&lt;/li&gt;
&lt;li&gt;Symbol binding&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;function-application&#34;&gt;Function application&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(f &amp;lt;arg&amp;gt; &amp;lt;arg&amp;gt; ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(+ 1 2 3 4)
(/ (+ 1 2 3 4) 4.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;function-abstraction&#34;&gt;Function Abstraction&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(fn &amp;lt;alias?&amp;gt; [ &amp;lt;args&amp;gt; ] &amp;lt;body&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(fn [a b] (/ (+ a b) 2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Computing the average of two numbers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(fn factorial [n]
  (if (&amp;lt; n 2) n (* n (factorial (dec n)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Recursion function that uses an alias &lt;code&gt;factorial&lt;/code&gt; for itself.  The alias is only valid in the body of the &lt;code&gt;fn&lt;/code&gt; defintion.&lt;/p&gt;

&lt;h1 id=&#34;symbol-binding&#34;&gt;Symbol binding&lt;/h1&gt;

&lt;p&gt;Symbols are just names, and they can be used to represent anything, such as:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;expressions&lt;/li&gt;
&lt;li&gt;functions&lt;/li&gt;
&lt;li&gt;variables&lt;/li&gt;
&lt;li&gt;lists (or programs)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: &lt;em&gt;Symbols Binding&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When we associate a symbol to something else, the &lt;em&gt;association&lt;/em&gt; is called a &lt;em&gt;binding&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;symbol-binding-1&#34;&gt;Symbol binding&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;binding.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;global-symbol-binding&#34;&gt;Global symbol binding&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def &amp;lt;symbol&amp;gt; &amp;lt;expression&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Creates a global symbol binding that exists throughout the entire &lt;em&gt;namespace&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;More on &lt;em&gt;namespaces&lt;/em&gt; later&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def PI 3.1415)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def area-of-circle (fn [r] (* r r PI)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(area-of-circle 100)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;global-symbol-binding-1&#34;&gt;Global symbol binding&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Must resist the usage of global symbol binding.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Java/C/C++ tend to bind functions to global symbols.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Because functions are values, think of functions as simple as &lt;em&gt;integers&lt;/em&gt;.
So, Clojure requires minimal global symbol binding.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;em&gt;local binding&lt;/em&gt; (coming up next) as much as you can.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;local-symbol-binding&#34;&gt;Local symbol binding&lt;/h1&gt;

&lt;p&gt;We want to create new symbol bindings in expressions &lt;em&gt;on-the-fly&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;lang-nosyntax&#34; data-noescape&gt;(def two-circles
  &lt;span style=&#34;color:#944;
                border:thin solid #888;
                padding:5px;
                margin:5px;
                font-weight: bold;
                display:inline-block&#34;&gt;(+ (* 3.1415 100 100) (* 3.1415 100 100))&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Let&amp;rsquo;s create a symbol bindings which are &lt;em&gt;only&lt;/em&gt; valid in the inner-expression.&lt;/p&gt;

&lt;h2 id=&#34;span-style-color-red-bad-idea-span&#34;&gt;&lt;span style=color:red&gt;BAD IDEA&lt;/span&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def PI 3.1415)
(def radius 100)
(def area (* 3.1415 radius radius))
(def two-circles (+ area area))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
Why is it bad?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;radius&lt;/code&gt; is not really a universal constant.  It&amp;rsquo;s 100 only for this expression.&lt;/li&gt;
&lt;li&gt;same for area.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;local-symbol-binding-1&#34;&gt;Local Symbol Binding&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(...
  (let [&amp;lt;symbol&amp;gt; &amp;lt;expression&amp;gt;
        &amp;lt;symbol&amp;gt; &amp;lt;expression&amp;gt;
        ...]
    &amp;lt;inner-expression&amp;gt;) ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def PI 3.1415)
(def two-circle
  (let [r    100
        area (* PI r r)]
    (+ r r)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Can you summarize why local symbol binding is more desirable to compute the value of &lt;code&gt;two-circle&lt;/code&gt;?&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Atoms&lt;/li&gt;
&lt;li&gt;Lists as code and code as lists&lt;/li&gt;
&lt;li&gt;Functions&lt;/li&gt;
&lt;li&gt;Invocation of functions&lt;/li&gt;
&lt;li&gt;Symbol bindings (global v.s. local)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>